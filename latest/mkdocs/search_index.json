{
    "docs": [
        {
            "location": "/", 
            "text": "Analysis of ecological networks\n\n\nThe \nEcologicalNetwork\n package offers a convenient interface to analyse several types of ecological networks. Rather than providing multiple measures of the same property, we selected measures that have been demonstrated to work and be robust.\n\n\n\n\nOverview of methods\n\n\nThis table gives an overview of the currently available methods, as a function of the network type. In the \nQuantitative\n column, a \nD\n means that the method exists \nbut\n works on the \nDeterministic\n part of the network (\ni.e.\n the information about interaction weight is removed).\n\n\n\n\n\n\n\n\nMeasure type\n\n\nMeasure\n\n\nDeterministic\n\n\nQuantitative\n\n\nProbabilistic\n\n\n\n\n\n\n\n\n\n\ndegree\n\n\n\n\nyes\n\n\nyes\n\n\nyes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecificity\n\n\nPDI\n\n\n\n\nyes\n\n\n\n\n\n\n\n\n\n\nRR\n\n\nyes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconnectance\n\n\n\n\nyes\n\n\nD\n\n\nyes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlink density\n\n\n\n\nyes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nnestedness\n\n\n$\\eta$\n\n\nbipartite\n\n\n\n\nbipartite\n\n\n\n\n\n\n\n\nNODF\n\n\nbipartite\n\n\n\n\n\n\n\n\n\n\n\n\nWNODF\n\n\n\n\nbipartite\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodularity\n\n\n$Q$\n\n\nyes\n\n\nyes\n\n\nyes\n\n\n\n\n\n\n\n\n$Q'_R$\n\n\nyes\n\n\nyes\n\n\nyes\n\n\n\n\n\n\n\n\nlabel propagation\n\n\nyes\n\n\nyes\n\n\nyes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmotif counting\n\n\n\n\nyes\n\n\nD\n\n\nyes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nnull models\n\n\n1 (connectance)\n\n\nyes\n\n\n\n\n\n\n\n\n\n\n\n\n2 (degree)\n\n\nyes\n\n\n\n\n\n\n\n\n\n\n\n\n3in (columns)\n\n\nyes\n\n\n\n\n\n\n\n\n\n\n\n\n3out (rows)\n\n\nyes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nswap\n\n\nfill\n\n\nyes\n\n\n\n\n\n\n\n\n\n\n\n\ngenerality\n\n\nyes\n\n\n\n\n\n\n\n\n\n\n\n\nvulnerability\n\n\nyes\n\n\n\n\n\n\n\n\n\n\n\n\ndegre distribution\n\n\nyes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncentrality\n\n\nKatz\n\n\nyes\n\n\n\n\nyes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nnumber of paths\n\n\n\n\nyes\n\n\n\n\nyes", 
            "title": "Home"
        }, 
        {
            "location": "/#analysis-of-ecological-networks", 
            "text": "The  EcologicalNetwork  package offers a convenient interface to analyse several types of ecological networks. Rather than providing multiple measures of the same property, we selected measures that have been demonstrated to work and be robust.", 
            "title": "Analysis of ecological networks"
        }, 
        {
            "location": "/#overview-of-methods", 
            "text": "This table gives an overview of the currently available methods, as a function of the network type. In the  Quantitative  column, a  D  means that the method exists  but  works on the  Deterministic  part of the network ( i.e.  the information about interaction weight is removed).     Measure type  Measure  Deterministic  Quantitative  Probabilistic      degree   yes  yes  yes           specificity  PDI   yes      RR  yes             connectance   yes  D  yes           link density   yes             nestedness  $\\eta$  bipartite   bipartite     NODF  bipartite       WNODF   bipartite            modularity  $Q$  yes  yes  yes     $Q'_R$  yes  yes  yes     label propagation  yes  yes  yes           motif counting   yes  D  yes           null models  1 (connectance)  yes       2 (degree)  yes       3in (columns)  yes       3out (rows)  yes             swap  fill  yes       generality  yes       vulnerability  yes       degre distribution  yes             centrality  Katz  yes   yes           number of paths   yes   yes", 
            "title": "Overview of methods"
        }, 
        {
            "location": "/usecase/nestedness/", 
            "text": "Measuring the nestedness of a network\n\n\nThe goal of this use case is to (i) measure the nestedness of a bipartite network and (ii) evaluate whether it differs from the random expectation. We will use the \nollerton\n data, which are reasonably small, and the \n\u03b7\n measure of nestedness (note that \nnodf\n is also available).\n\n\nusing\n \nEcologicalNetwork\n\n\n\n# Get the data in an object\n\n\nN\n \n=\n \nollerton\n();\n\n\n\n# We will create a function to return the nestedness of the entire\n\n\n# network instead of an array of nestedness values\n\n\nnest\n \n=\n \n(\nx\n)\n \n-\n \n\u03b7\n(\nx\n)[\n1\n]\n\n\n\n# We will now generate a series of random networks preserving the degree\n\n\n# distribution\n\n\nS\n \n=\n \nnullmodel\n(\nnull2\n(\nN\n));\n\n\n\n# There is a function to apply a test rapidly to randomized networks. In this\n\n\n# situation we are interested in testing the fact that the network is more\n\n\n# nested than expected by chance.\n\n\nresults\n \n=\n \ntest_network_property\n(\nN\n,\n \nnest\n,\n \nS\n,\n\n        \ntest\n=:\ngreater\n);\n\n\n\n# We can print the results\n\n\nprintln\n(\n\n        \nThe original network has a nestedness of \n,\n\n        \nround\n(\nnest\n(\nN\n),\n \n3\n),\n\n        \n,\n\\n\n,\n \nwhich is greater than expected by chance (p ~ \n,\n\n        \nround\n(\nresults\n.\npval\n,\n \n4\n),\n\n        \n) -- \n,\n\n        \nresults\n.\nn\n,\n\n        \n random networks.\n\n        \n)\n\n\n\n\n\n\nThe original network has a nestedness of 0.641,\nwhich is greater than expected by chance (p ~ 0.0) -- 291 random networks.\n\n\n\n\n\nIn this simple example, we used \nnullmodel\n to generate random realizations of a network, and \ntest_network_property\n to evaluate whether the observed nestedness was observed by chance. As it stands, all randomized networks had \nlower\n values, and so the \np\n-value is (essentially) null. In short, this network is significantly more nested than expected by chance knowing its degree distribution.\n\n\nWe can also decide to plot the network to visualize what it looks like:\n\n\njulia\n \nusing\n \nEcologicalNetwork\n\n\n\njulia\n \nN\n \n=\n \nollerton\n()\n\n\nEcologicalNetwork\n.\nBipartiteNetwork\n(\nBool\n[\ntrue\n \ntrue\n \n\u2026\n \ntrue\n \ntrue\n;\n \ntrue\n \ntrue\n \n\u2026\n \nfalse\n \nfalse\n;\n \n\u2026\n \n;\n \nfalse\n \nfalse\n \n\u2026\n \nfalse\n \nfalse\n;\n \nfalse\n \ntrue\n \n\u2026\n \nfalse\n \nfalse\n])\n\n\n\njulia\n \nplot_network\n(\nN\n,\n \nfile\n=\nollerton.png\n)\n\n\n\n\n\n\nThis is what the result should look like:", 
            "title": "Nestedness"
        }, 
        {
            "location": "/usecase/nestedness/#measuring-the-nestedness-of-a-network", 
            "text": "The goal of this use case is to (i) measure the nestedness of a bipartite network and (ii) evaluate whether it differs from the random expectation. We will use the  ollerton  data, which are reasonably small, and the  \u03b7  measure of nestedness (note that  nodf  is also available).  using   EcologicalNetwork  # Get the data in an object  N   =   ollerton ();  # We will create a function to return the nestedness of the entire  # network instead of an array of nestedness values  nest   =   ( x )   -   \u03b7 ( x )[ 1 ]  # We will now generate a series of random networks preserving the degree  # distribution  S   =   nullmodel ( null2 ( N ));  # There is a function to apply a test rapidly to randomized networks. In this  # situation we are interested in testing the fact that the network is more  # nested than expected by chance.  results   =   test_network_property ( N ,   nest ,   S , \n         test =: greater );  # We can print the results  println ( \n         The original network has a nestedness of  , \n         round ( nest ( N ),   3 ), \n         , \\n ,   which is greater than expected by chance (p ~  , \n         round ( results . pval ,   4 ), \n         ) --  , \n         results . n , \n          random networks. \n         )   The original network has a nestedness of 0.641,\nwhich is greater than expected by chance (p ~ 0.0) -- 291 random networks.  In this simple example, we used  nullmodel  to generate random realizations of a network, and  test_network_property  to evaluate whether the observed nestedness was observed by chance. As it stands, all randomized networks had  lower  values, and so the  p -value is (essentially) null. In short, this network is significantly more nested than expected by chance knowing its degree distribution.  We can also decide to plot the network to visualize what it looks like:  julia   using   EcologicalNetwork  julia   N   =   ollerton ()  EcologicalNetwork . BipartiteNetwork ( Bool [ true   true   \u2026   true   true ;   true   true   \u2026   false   false ;   \u2026   ;   false   false   \u2026   false   false ;   false   true   \u2026   false   false ])  julia   plot_network ( N ,   file = ollerton.png )   This is what the result should look like:", 
            "title": "Measuring the nestedness of a network"
        }, 
        {
            "location": "/usecase/modularity/", 
            "text": "Measuring the modularity\n\n\nIn this example, we will use \nlabel_propagation\n to optimize the modularity of a network. The data are from the \nmcmullen\n dataset.\n\n\nusing\n \nEcologicalNetwork\n\n\n\n# Get the data in an object\n\n\nN\n \n=\n \nmcmullen\n();\n\n\n\n# We will start with a random assignment of species within modules\n\n\nL\n \n=\n \nrand\n(\n1\n:\nrichness\n(\nN\n),\n \nrichness\n(\nN\n));\n\n\n\n# We can now start a repeated number of attempts to find the best partition. If\n\n\n# julia is started in parallel, this will use all assigned CPUs.\n\n\nM\n \n=\n \nmodularity\n(\nN\n,\n \nL\n,\n \nreplicates\n=\n100\n);\n\n\n\n# Finally, we can get the best partition\n\n\nb_part\n \n=\n \nbest_partition\n(\nM\n);\n\n\n\n# And print its modularity and number of modules\n\n\nprintln\n(\nQ: \n,\n\n        \nround\n(\nb_part\n[\n1\n]\n.\nQ\n,\n \n2\n),\n\n        \n |c|: \n,\n\n        \nlength\n(\nunique\n(\nb_part\n[\n1\n]\n.\nL\n))\n\n        \n)\n\n\n\n\n\n\nQ\n:\n \n0.54\n \n|\nc\n|:\n \n18", 
            "title": "Modularity"
        }, 
        {
            "location": "/usecase/modularity/#measuring-the-modularity", 
            "text": "In this example, we will use  label_propagation  to optimize the modularity of a network. The data are from the  mcmullen  dataset.  using   EcologicalNetwork  # Get the data in an object  N   =   mcmullen ();  # We will start with a random assignment of species within modules  L   =   rand ( 1 : richness ( N ),   richness ( N ));  # We can now start a repeated number of attempts to find the best partition. If  # julia is started in parallel, this will use all assigned CPUs.  M   =   modularity ( N ,   L ,   replicates = 100 );  # Finally, we can get the best partition  b_part   =   best_partition ( M );  # And print its modularity and number of modules  println ( Q:  , \n         round ( b_part [ 1 ] . Q ,   2 ), \n          |c|:  , \n         length ( unique ( b_part [ 1 ] . L )) \n         )   Q :   0.54   | c |:   18", 
            "title": "Measuring the modularity"
        }, 
        {
            "location": "/usecase/motifs/", 
            "text": "Counting motifs\n\n\nIn this use case, we will count the number of motifs in a food web. Specifically, we will count how many times there is a linear food chain (A\u2192B\u2192C) between three species.\n\n\nusing\n \nEcologicalNetwork\n\n\n\n# Load a network\n\n\nN\n \n=\n \nstony\n();\n\n\n\n# List of motifs\n\n\nm\n \n=\n \nunipartitemotifs\n();\n\n\n\n\n\n\nDict{Symbol,EcologicalNetwork.UnipartiteNetwork} with 13 entries:\n  :S4 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :S1 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :D6 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true true; true false t\u2026\n  :D3 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false false true; false false\u2026\n  :S2 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026\n  :D8 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true true; true false f\u2026\n  :D1 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026\n  :D7 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true true; true false f\u2026\n  :D5 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :S3 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :D4 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :S5 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026\n  :D2 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026\n\n\n\n\n\nThe \nm\n object has 13 different motifs, named as in [Stouffer \net al.\n (2007)][sto]. The function \nunipartitemotifs\n will generate them when needed. Let's look at the \nm[:S1]\n motif:\n\n\n```@example\n\n\nplot_network(m[:S1], file=\"motifs1.png\")\n\n\n!\n[\nmotif\n \ns1\n][\nms1\n]\n\n\n\n\n[\nms1\n]\n:\n \nmotifs1\n.\npng\n\n\n\n\n[\nsto\n]\n:\n \nhttp\n:\n//rspb.royalsocietypublishing.org/content/274/1621/1931\n\n\n\n\nThe\n \nfunction\n \nto\n \ncount\n \nmotifs\n \nis\n \ncalled\n \n[\n`\nmotif\n`\n](..\n/\nlib\n/\ninternals\n.\nmd\n#\nEcologicalNetwork\n.\nmotif\n-\nTuple\n{\nEcologicalNetwork\n.\nEcoNetwork\n,\nUnion\n{\nEcologicalNetwork\n.\nBipartiteNetwork\n,\nEcologicalNetwork\n.\nUnipartiteNetwork\n}}),\n \nand\n \nreturns\n \na\n \ncount\n:\n \nhow\n \nmany\n \ntriplets\n \nof\n \nspecies\n \nare\n \nin\n \na\n \ngiven\n \nconformation\n.\n \nFor\n \nexample\n:\n\n\n\n\n```\n@\nexample\n\n\ns1\n \n=\n \nmotif\n(\nN\n,\n \nm\n[\n:\nS1\n])\n\n\n\n\n\n\nWe may be interested in knowing whether this motif is over or under-represented in the empirical network, compared to a random expectation. To determine this, we will shuffle interactions around in a way that preserves the distribution of degrees, using \nswaps\n. We will create 100 replicated networks to test.\n\n\n@example\npermutations = swaps(N, 100, constraint=:degree)\nms1 = map(x -\n motif(x, m[:S1]), permutations)", 
            "title": "Motifs"
        }, 
        {
            "location": "/usecase/motifs/#counting-motifs", 
            "text": "In this use case, we will count the number of motifs in a food web. Specifically, we will count how many times there is a linear food chain (A\u2192B\u2192C) between three species.  using   EcologicalNetwork  # Load a network  N   =   stony ();  # List of motifs  m   =   unipartitemotifs ();   Dict{Symbol,EcologicalNetwork.UnipartiteNetwork} with 13 entries:\n  :S4 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :S1 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :D6 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true true; true false t\u2026\n  :D3 =  EcologicalNetwork.UnipartiteNetwork(Bool[false false true; false false\u2026\n  :S2 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026\n  :D8 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true true; true false f\u2026\n  :D1 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026\n  :D7 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true true; true false f\u2026\n  :D5 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :S3 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :D4 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :S5 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026\n  :D2 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026  The  m  object has 13 different motifs, named as in [Stouffer  et al.  (2007)][sto]. The function  unipartitemotifs  will generate them when needed. Let's look at the  m[:S1]  motif:  ```@example  plot_network(m[:S1], file=\"motifs1.png\")  ! [ motif   s1 ][ ms1 ]  [ ms1 ] :   motifs1 . png  [ sto ] :   http : //rspb.royalsocietypublishing.org/content/274/1621/1931  The   function   to   count   motifs   is   called   [ ` motif ` ](.. / lib / internals . md # EcologicalNetwork . motif - Tuple { EcologicalNetwork . EcoNetwork , Union { EcologicalNetwork . BipartiteNetwork , EcologicalNetwork . UnipartiteNetwork }}),   and   returns   a   count :   how   many   triplets   of   species   are   in   a   given   conformation .   For   example :  ``` @ example  s1   =   motif ( N ,   m [ : S1 ])   We may be interested in knowing whether this motif is over or under-represented in the empirical network, compared to a random expectation. To determine this, we will shuffle interactions around in a way that preserves the distribution of degrees, using  swaps . We will create 100 replicated networks to test.  @example\npermutations = swaps(N, 100, constraint=:degree)\nms1 = map(x -  motif(x, m[:S1]), permutations)", 
            "title": "Counting motifs"
        }, 
        {
            "location": "/man/types/", 
            "text": "Informations about types\n\n\nAs there are many ways to represent ecological networks, and the correct way to measure a given property varies in function of the representation, \nEcologicalNetwork\n has a series of built-in types.\n\n\n\n\nType hierarchy\n\n\nThe \nEcologicalNetwork\n package has six main types that are meant to be used by the user: \nBipartiteNetwork\n, \nBipartiteProbaNetwork\n, \nBipartiteQuantiNetwork\n, \nUnipartiteNetwork\n, \nUnipartiteProbaNetwork\n and \nUnipartiteQuantiNetwork\n. All types with \nProba\n in their names are meant to represent probabilistic networks, and are also part of the union type \nProbabilisticNetwork\n. All types \nwithout\n \nProba\n in their name are part of the union type \nDeterministicNetwork\n, and represent networks in which interactions are either present or absent. All types with \nQuanti\n in their names are part of the \nQuantitativeNetwork\n groups, and represent networks with weighted interactions. All types starting with \nBipartite\n are also part of the abstract type \nBipartite\n, and types with \nUnipartite\n in their names are part of the abstract type \nUnipartite\n. Finally, both \nUnipartite\n and \nBipartite\n are part of the abstract type \nEcoNetwork\n.\n\n\nAlthough this may seem convoluted, this is important to understand: when writing functions, you can restrict them to any type of network you want by using the right type in their declaration. You can also check properties of a network just by looking at its type. For example, one can check whether a network \nN\n is bipartite with:\n\n\ntypeof\n(\nN\n)\n \n:\n \nBipartite\n\n\n\n\n\n\nNetworks are represented as two-dimensional matrices. All types are simply wrappers around an adjacency matrix, stored as the \nA\n property of the object. To look at the adjacency matrix of a network \nN\n, one therefore uses \nN.A\n. These matrices must be read as: the existence/probability of an interaction \nfrom\n the species of the \ni\n-th row \nto\n the species in the \nj\n-th column. This implies that the networks are, by default, directed.\n\n\nNote that the type of a network will determine what methods can be applied to it. For example, all measures of variance are only making sense for probabilistic networks.\n\n\n\n\nData types\n\n\nInteractions in deterministic networks are represented as boolean (\ntrue\n/\nfalse\n) values. This is memory efficient, so large networks can be represented (one interactions represented as a boolean uses 8 times fewer memory than the same interaction represented as an integer). This being said, all networks of the \nDeterministicNetwork\n type can be read from matrices of integers, \nas long as these matrices only contain 0 and 1\n.\n\n\nIn probabilistic networks, interactions are stored as floating point (\nFloat64\n) numbers. These values have to be between 0.0 and 1.0, as they represent probabilities. In quantitative networks, interactions are stored as any type of number.\n\n\nNetworks of the \nUnipartite\n class must have the same number of rows and columns. The species in the rows and columns are the same. Networks of the \nBipartite\n class are expected to have different numbers of rows and columns, as the species in rows and columns are different species. It is possible to convert a network from \nBipartite\n to \nUnipartite\n using the \nmake_unipartite\n function:\n\n\nusing\n \nEcologicalNetwork\n\n\nB\n \n=\n \nBipartiteNetwork\n(\nrand\n(\nBool\n,\n \n(\n3\n,\n \n5\n)))\n\n\nU\n \n=\n \nmake_unipartite\n(\nB\n)\n\n\nrichness\n(\nU\n)\n \n==\n \nrichness\n(\nB\n)\n\n\n\n\n\n\ntrue\n\n\n\n\n\nThe documentation for \nmake_unipartite\n gives additional explanations about how the conversion is done. In the overwhelming majority of cases, applying any measure to a bipartite network, and to the same network made unipartite, should give the same results (connectance is one notable example).\n\n\n\n\nType reference", 
            "title": "Types"
        }, 
        {
            "location": "/man/types/#informations-about-types", 
            "text": "As there are many ways to represent ecological networks, and the correct way to measure a given property varies in function of the representation,  EcologicalNetwork  has a series of built-in types.", 
            "title": "Informations about types"
        }, 
        {
            "location": "/man/types/#type-hierarchy", 
            "text": "The  EcologicalNetwork  package has six main types that are meant to be used by the user:  BipartiteNetwork ,  BipartiteProbaNetwork ,  BipartiteQuantiNetwork ,  UnipartiteNetwork ,  UnipartiteProbaNetwork  and  UnipartiteQuantiNetwork . All types with  Proba  in their names are meant to represent probabilistic networks, and are also part of the union type  ProbabilisticNetwork . All types  without   Proba  in their name are part of the union type  DeterministicNetwork , and represent networks in which interactions are either present or absent. All types with  Quanti  in their names are part of the  QuantitativeNetwork  groups, and represent networks with weighted interactions. All types starting with  Bipartite  are also part of the abstract type  Bipartite , and types with  Unipartite  in their names are part of the abstract type  Unipartite . Finally, both  Unipartite  and  Bipartite  are part of the abstract type  EcoNetwork .  Although this may seem convoluted, this is important to understand: when writing functions, you can restrict them to any type of network you want by using the right type in their declaration. You can also check properties of a network just by looking at its type. For example, one can check whether a network  N  is bipartite with:  typeof ( N )   :   Bipartite   Networks are represented as two-dimensional matrices. All types are simply wrappers around an adjacency matrix, stored as the  A  property of the object. To look at the adjacency matrix of a network  N , one therefore uses  N.A . These matrices must be read as: the existence/probability of an interaction  from  the species of the  i -th row  to  the species in the  j -th column. This implies that the networks are, by default, directed.  Note that the type of a network will determine what methods can be applied to it. For example, all measures of variance are only making sense for probabilistic networks.", 
            "title": "Type hierarchy"
        }, 
        {
            "location": "/man/types/#data-types", 
            "text": "Interactions in deterministic networks are represented as boolean ( true / false ) values. This is memory efficient, so large networks can be represented (one interactions represented as a boolean uses 8 times fewer memory than the same interaction represented as an integer). This being said, all networks of the  DeterministicNetwork  type can be read from matrices of integers,  as long as these matrices only contain 0 and 1 .  In probabilistic networks, interactions are stored as floating point ( Float64 ) numbers. These values have to be between 0.0 and 1.0, as they represent probabilities. In quantitative networks, interactions are stored as any type of number.  Networks of the  Unipartite  class must have the same number of rows and columns. The species in the rows and columns are the same. Networks of the  Bipartite  class are expected to have different numbers of rows and columns, as the species in rows and columns are different species. It is possible to convert a network from  Bipartite  to  Unipartite  using the  make_unipartite  function:  using   EcologicalNetwork  B   =   BipartiteNetwork ( rand ( Bool ,   ( 3 ,   5 )))  U   =   make_unipartite ( B )  richness ( U )   ==   richness ( B )   true  The documentation for  make_unipartite  gives additional explanations about how the conversion is done. In the overwhelming majority of cases, applying any measure to a bipartite network, and to the same network made unipartite, should give the same results (connectance is one notable example).", 
            "title": "Data types"
        }, 
        {
            "location": "/man/types/#type-reference", 
            "text": "", 
            "title": "Type reference"
        }, 
        {
            "location": "/man/data/", 
            "text": "Datasets\n\n\nEcologicalNetwork\n comes with a few datasets.\n\n\n\n\nUnipartite networks\n\n\n#\n\n\nEcologicalNetwork.stony\n \n \nFunction\n.\n\n\nStony food web from Thompson \n Townsend. This was sampled in a tussock grassland near Otago, New Zealand.\n\n\nsource\n\n\n\n\nBipartite networks\n\n\n#\n\n\nEcologicalNetwork.ollerton\n \n \nFunction\n.\n\n\nFish-anemone interactions from Ollerton et al. 2007\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.mcmullen\n \n \nFunction\n.\n\n\nPlant-flower visitor interactions in the Galapagos.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.robertson\n \n \nFunction\n.\n\n\nPollination interaction from Robertson 1927, in an agricultural area dominated by crops, with some natural forest and pasture.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.bluthgen\n \n \nFunction\n.\n\n\nNumber of visits from Bluthgen et al XXX\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.woods\n \n \nFunction\n.\n\n\nLake of the Woods host-parasite data. Interactions content are prevalence.\n\n\nsource", 
            "title": "Data"
        }, 
        {
            "location": "/man/data/#datasets", 
            "text": "EcologicalNetwork  comes with a few datasets.", 
            "title": "Datasets"
        }, 
        {
            "location": "/man/data/#unipartite-networks", 
            "text": "#  EcologicalNetwork.stony     Function .  Stony food web from Thompson   Townsend. This was sampled in a tussock grassland near Otago, New Zealand.  source", 
            "title": "Unipartite networks"
        }, 
        {
            "location": "/man/data/#bipartite-networks", 
            "text": "#  EcologicalNetwork.ollerton     Function .  Fish-anemone interactions from Ollerton et al. 2007  source  #  EcologicalNetwork.mcmullen     Function .  Plant-flower visitor interactions in the Galapagos.  source  #  EcologicalNetwork.robertson     Function .  Pollination interaction from Robertson 1927, in an agricultural area dominated by crops, with some natural forest and pasture.  source  #  EcologicalNetwork.bluthgen     Function .  Number of visits from Bluthgen et al XXX  source  #  EcologicalNetwork.woods     Function .  Lake of the Woods host-parasite data. Interactions content are prevalence.  source", 
            "title": "Bipartite networks"
        }, 
        {
            "location": "/man/nullmodels/", 
            "text": "Null models\n\n\nEcologicalNetwork\n offers a number of ways to draw random binary networks from a template of probabilities. This is useful to generate networks under a null model, for example. All these functions will respect the fact that the network in bipartite or unipartite.\n\n\n\n\nCreating a deterministic network from a probabilistic network\n\n\nThere are a number of ways to generate a deterministic network from a probabilistic one. All of these functions take a network on a class belonging to \nProbabilisticNetwork\n, and return a network of a class belonging to \nDeterministicNetwork\n.\n\n\n\n\nConvert to deterministic\n\n\nThe first is simply to assing \ntrue\n to all interactions with a non-0 probability, and \nfalse\n to the others. This is done with the \nmake_binary\n function:\n\n\nN\n \n=\n \nUnipartiteProbaNetwork\n(\neye\n(\n3\n))\n\n\nB\n \n=\n \nmake_binary\n(\nN\n)\n\n\nB\n.\nA\n\n\n\n\n\n\n3\u00d73 Array{Bool,2}:\n  true  false  false\n false   true  false\n false  false   true\n\n\n\n\n\n#\n\n\nEcologicalNetwork.make_binary\n \n \nFunction\n.\n\n\nReturns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is greater than 0.\n\n\nsource\n\n\n\n\nUsing a threshold\n\n\nThe second way is to determine a cutoff for probabilities, below which they will be assigned \nfalse\n. This is done through \nmake_threshold\n:\n\n\nN\n \n=\n \nUnipartiteProbaNetwork\n(\nrand\n((\n4\n,\n \n4\n)))\n\n\nB\n \n=\n \nmake_threshold\n(\nN\n,\n \n0.5\n)\n\n\nB\n.\nA\n\n\n\n\n\n\n4\u00d74 Array{Bool,2}:\n  true  true  false  false\n false  true  false  false\n false  true   true   true\n  true  true   true   true\n\n\n\n\n\n#\n\n\nEcologicalNetwork.make_threshold\n \n \nFunction\n.\n\n\nReturns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is \n \nk\n. This is probably unwise to use this function since this practice is of questionnable relevance, but it is included for the sake of exhaustivity.\n\n\nk\n must be in [0;1[.\n\n\nsource\n\n\n\n\nRandom draws\n\n\nThe last way to convert a probabilistic network to a deterministic one is to perform one random draw for each interaction. In this scenario, \ntrue\n is assigned with a probability $P_{ij}$. This is done with the \nmake_bernoulli\n function:\n\n\nN\n \n=\n \nBipartiteProbaNetwork\n(\nrand\n((\n4\n,\n \n4\n)))\n\n\nB\n \n=\n \nmake_bernoulli\n(\nN\n)\n\n\nB\n.\nA\n\n\n\n\n\n\n4\u00d74 Array{Bool,2}:\n false   true  false  false\n false   true  false  false\n false  false  false  false\n false   true   true  false\n\n\n\n\n\n#\n\n\nEcologicalNetwork.make_bernoulli\n \n \nFunction\n.\n\n\nReturns a matrix B of the same size as A, in which each element B(i,j) is 1 with probability A(i,j).\n\n\nsource\n\n\n\n\nCreating a probabilistic network from a deterministic network\n\n\nThe inverse operation can be done using the \nnullX\n functions. These functions use informations about the degree distribution to generate probabilistic networks:\n\n\n#\n\n\nEcologicalNetwork.null1\n \n \nFunction\n.\n\n\nGiven a matrix \nA\n, \nnull1(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the connectance of \nA\n.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null2\n \n \nFunction\n.\n\n\nGiven a matrix \nA\n, \nnull2(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the degree of each species.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null3in\n \n \nFunction\n.\n\n\nGiven a matrix \nA\n, \nnull3in(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the in-degree (number of predecessors) of each species, divided by the total number of possible predecessors.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null3out\n \n \nFunction\n.\n\n\nGiven a matrix \nA\n, \nnull3out(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the out-degree (number of successors) of each species, divided by the total number of possible successors.\n\n\nsource\n\n\nFor an example:\n\n\nN\n \n=\n \nmake_bernoulli\n(\nBipartiteProbaNetwork\n(\nrand\n(\n3\n,\n \n5\n)))\n\n\nnull2\n(\nN\n)\n.\nA\n\n\n\n\n\n\n3\u00d75 Array{Float64,2}:\n 0.633333  0.633333  0.633333  0.633333  0.466667\n 0.733333  0.733333  0.733333  0.733333  0.566667\n 0.533333  0.533333  0.533333  0.533333  0.366667\n\n\n\n\n\n\n\nNull model wrapper\n\n\nEcologicalNetwork\n has a wrapper to generate an arbitrary number of Bernoulli networks from a probability matrix. This approach is encourage over simply generating your own networks, because the wrapper will make sure that all networks have no species without any interactions. This ensures that the networks have the same size.\n\n\nFor example, we can generate a hundred replicates from the \nstony\n food web dataset, using the type 2 model:\n\n\ntemplate\n \n=\n \nnull2\n(\nstony\n())\n\n\n\n# Generate up to 100 networks\n\n\nN\n \n=\n \nnullmodel\n(\ntemplate\n,\n \nn\n=\n100\n,\n \nmax\n=\n1000\n)\n\n\n\n# Average connectance\n\n\nmean\n(\nmap\n(\nconnectance\n,\n \nN\n))\n\n\n\n\n\n\n0.06485942517033441\n\n\n\n\n\nIt must be noted that the number of networks returned by \nnullmodel\n may be \nlower\n than the requested number of networks. This is because of the constraint on the fact that no species can end up without interactions. When this constrained is enforced, some networks have very low success rates. This can be measured using the \nspecies_is_free\n function:\n\n\ntemplate\n \n=\n \nnull2\n(\nmcmullen\n())\n\n\n\n# Probability that every species has at least one interaction\n\n\nat_least_one\n \n=\n \n1.\n-\nspecies_is_free\n(\nmake_unipartite\n(\ntemplate\n))\n\n\n\n# Probability that a randomized network has no unconnected species\n\n\nprod\n(\nat_least_one\n)\n\n\n\n\n\n\n1.1674941263628132e-10\n\n\n\n\n\n#\n\n\nEcologicalNetwork.nullmodel\n \n \nFunction\n.\n\n\nThis function is a wrapper to generate replicated binary matrices from a template probability matrix \nA\n.\n\n\nIf you use julia on more than one CPU, \ni.e.\n if you started it with \njulia -p k\n where \nk\n is more than 1, this function will distribute each trial to one worker. Which means that it's fast.\n\n\nKeyword arguments\n\n\n\n\nn\n (def. 1000), number of replicates to generate\n\n\nmax\n (def. 10000), number of trials to make\n\n\n\n\nsource", 
            "title": "Null models"
        }, 
        {
            "location": "/man/nullmodels/#null-models", 
            "text": "EcologicalNetwork  offers a number of ways to draw random binary networks from a template of probabilities. This is useful to generate networks under a null model, for example. All these functions will respect the fact that the network in bipartite or unipartite.", 
            "title": "Null models"
        }, 
        {
            "location": "/man/nullmodels/#creating-a-deterministic-network-from-a-probabilistic-network", 
            "text": "There are a number of ways to generate a deterministic network from a probabilistic one. All of these functions take a network on a class belonging to  ProbabilisticNetwork , and return a network of a class belonging to  DeterministicNetwork .", 
            "title": "Creating a deterministic network from a probabilistic network"
        }, 
        {
            "location": "/man/nullmodels/#convert-to-deterministic", 
            "text": "The first is simply to assing  true  to all interactions with a non-0 probability, and  false  to the others. This is done with the  make_binary  function:  N   =   UnipartiteProbaNetwork ( eye ( 3 ))  B   =   make_binary ( N )  B . A   3\u00d73 Array{Bool,2}:\n  true  false  false\n false   true  false\n false  false   true  #  EcologicalNetwork.make_binary     Function .  Returns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is greater than 0.  source", 
            "title": "Convert to deterministic"
        }, 
        {
            "location": "/man/nullmodels/#using-a-threshold", 
            "text": "The second way is to determine a cutoff for probabilities, below which they will be assigned  false . This is done through  make_threshold :  N   =   UnipartiteProbaNetwork ( rand (( 4 ,   4 )))  B   =   make_threshold ( N ,   0.5 )  B . A   4\u00d74 Array{Bool,2}:\n  true  true  false  false\n false  true  false  false\n false  true   true   true\n  true  true   true   true  #  EcologicalNetwork.make_threshold     Function .  Returns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is    k . This is probably unwise to use this function since this practice is of questionnable relevance, but it is included for the sake of exhaustivity.  k  must be in [0;1[.  source", 
            "title": "Using a threshold"
        }, 
        {
            "location": "/man/nullmodels/#random-draws", 
            "text": "The last way to convert a probabilistic network to a deterministic one is to perform one random draw for each interaction. In this scenario,  true  is assigned with a probability $P_{ij}$. This is done with the  make_bernoulli  function:  N   =   BipartiteProbaNetwork ( rand (( 4 ,   4 )))  B   =   make_bernoulli ( N )  B . A   4\u00d74 Array{Bool,2}:\n false   true  false  false\n false   true  false  false\n false  false  false  false\n false   true   true  false  #  EcologicalNetwork.make_bernoulli     Function .  Returns a matrix B of the same size as A, in which each element B(i,j) is 1 with probability A(i,j).  source", 
            "title": "Random draws"
        }, 
        {
            "location": "/man/nullmodels/#creating-a-probabilistic-network-from-a-deterministic-network", 
            "text": "The inverse operation can be done using the  nullX  functions. These functions use informations about the degree distribution to generate probabilistic networks:  #  EcologicalNetwork.null1     Function .  Given a matrix  A ,  null1(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the connectance of  A .  source  #  EcologicalNetwork.null2     Function .  Given a matrix  A ,  null2(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the degree of each species.  source  #  EcologicalNetwork.null3in     Function .  Given a matrix  A ,  null3in(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the in-degree (number of predecessors) of each species, divided by the total number of possible predecessors.  source  #  EcologicalNetwork.null3out     Function .  Given a matrix  A ,  null3out(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the out-degree (number of successors) of each species, divided by the total number of possible successors.  source  For an example:  N   =   make_bernoulli ( BipartiteProbaNetwork ( rand ( 3 ,   5 )))  null2 ( N ) . A   3\u00d75 Array{Float64,2}:\n 0.633333  0.633333  0.633333  0.633333  0.466667\n 0.733333  0.733333  0.733333  0.733333  0.566667\n 0.533333  0.533333  0.533333  0.533333  0.366667", 
            "title": "Creating a probabilistic network from a deterministic network"
        }, 
        {
            "location": "/man/nullmodels/#null-model-wrapper", 
            "text": "EcologicalNetwork  has a wrapper to generate an arbitrary number of Bernoulli networks from a probability matrix. This approach is encourage over simply generating your own networks, because the wrapper will make sure that all networks have no species without any interactions. This ensures that the networks have the same size.  For example, we can generate a hundred replicates from the  stony  food web dataset, using the type 2 model:  template   =   null2 ( stony ())  # Generate up to 100 networks  N   =   nullmodel ( template ,   n = 100 ,   max = 1000 )  # Average connectance  mean ( map ( connectance ,   N ))   0.06485942517033441  It must be noted that the number of networks returned by  nullmodel  may be  lower  than the requested number of networks. This is because of the constraint on the fact that no species can end up without interactions. When this constrained is enforced, some networks have very low success rates. This can be measured using the  species_is_free  function:  template   =   null2 ( mcmullen ())  # Probability that every species has at least one interaction  at_least_one   =   1. - species_is_free ( make_unipartite ( template ))  # Probability that a randomized network has no unconnected species  prod ( at_least_one )   1.1674941263628132e-10  #  EcologicalNetwork.nullmodel     Function .  This function is a wrapper to generate replicated binary matrices from a template probability matrix  A .  If you use julia on more than one CPU,  i.e.  if you started it with  julia -p k  where  k  is more than 1, this function will distribute each trial to one worker. Which means that it's fast.  Keyword arguments   n  (def. 1000), number of replicates to generate  max  (def. 10000), number of trials to make   source", 
            "title": "Null model wrapper"
        }, 
        {
            "location": "/man/modularity/", 
            "text": "Measuring modularity\n\n\nThere are a number of modularity-related functions in \nEcologicalNetworks\n. The optimal modularity structure is detected by optimizing $Q$, which returns values increasingly close to unity when the modular structure is strong. The $Q'_R$ measure is also included for \na posteriori\n evaluation of the modularity.\n\n\n\n\nInitial module assignment\n\n\nThere are a number of ways to...", 
            "title": "Modularity"
        }, 
        {
            "location": "/man/modularity/#measuring-modularity", 
            "text": "There are a number of modularity-related functions in  EcologicalNetworks . The optimal modularity structure is detected by optimizing $Q$, which returns values increasingly close to unity when the modular structure is strong. The $Q'_R$ measure is also included for  a posteriori  evaluation of the modularity.", 
            "title": "Measuring modularity"
        }, 
        {
            "location": "/man/modularity/#initial-module-assignment", 
            "text": "There are a number of ways to...", 
            "title": "Initial module assignment"
        }, 
        {
            "location": "/man/motifs/", 
            "text": "Counting motifs\n\n\nThere are a number of ways to...\n\n\n\n\nNote\n\n\nThe enumeration of motifs can take a little while. It depends on the number of nodes in the networks, and in the number of nodes in the motif. It may be wise, in case you want to count several motifs on a single network, to use Julia's parallel computing abilities to speed things up.\n\n\n\n\n\n\nHow it works\n\n\nInternally, the code to count motifs is \nNot Elegant\n\u2122. Every motif is represented by its adjacency matrix, as a \nDeterministicNetwork\n object. Then \nall\n possible induced sub-graphs with the same number of nodes (at either level if this is a \nBipartite\n) are extracted, and matched against all \nunique\n possible permutations of the motif. If there is a match, then this induced subgraph is an instance of this motif.\n\n\nmotifs\n\n\n\n\n\n\n\nCaveats\n\n\nThe motifs are counted in a way that ignore self-links. This should not be an issue most of the time, and was also the ways this was done in most publications counting motifs in ecological networks.\n\n\n\n\nUsual motifs\n\n\n#\n\n\nEcologicalNetwork.unipartitemotifs\n \n \nFunction\n.\n\n\nReturns a dictionary of the usual unipartite motifs. The names of the motifs come from Stouffer et al. (2007) \u2013 especially Fig. 1, available online at \nhttp://rspb.royalsocietypublishing.org/content/274/1621/1931.figures-only\n\n\nsource", 
            "title": "Motifs"
        }, 
        {
            "location": "/man/motifs/#counting-motifs", 
            "text": "There are a number of ways to...   Note  The enumeration of motifs can take a little while. It depends on the number of nodes in the networks, and in the number of nodes in the motif. It may be wise, in case you want to count several motifs on a single network, to use Julia's parallel computing abilities to speed things up.", 
            "title": "Counting motifs"
        }, 
        {
            "location": "/man/motifs/#how-it-works", 
            "text": "Internally, the code to count motifs is  Not Elegant \u2122. Every motif is represented by its adjacency matrix, as a  DeterministicNetwork  object. Then  all  possible induced sub-graphs with the same number of nodes (at either level if this is a  Bipartite ) are extracted, and matched against all  unique  possible permutations of the motif. If there is a match, then this induced subgraph is an instance of this motif.  motifs", 
            "title": "How it works"
        }, 
        {
            "location": "/man/motifs/#caveats", 
            "text": "The motifs are counted in a way that ignore self-links. This should not be an issue most of the time, and was also the ways this was done in most publications counting motifs in ecological networks.", 
            "title": "Caveats"
        }, 
        {
            "location": "/man/motifs/#usual-motifs", 
            "text": "#  EcologicalNetwork.unipartitemotifs     Function .  Returns a dictionary of the usual unipartite motifs. The names of the motifs come from Stouffer et al. (2007) \u2013 especially Fig. 1, available online at  http://rspb.royalsocietypublishing.org/content/274/1621/1931.figures-only  source", 
            "title": "Usual motifs"
        }, 
        {
            "location": "/man/plotting/", 
            "text": "Plotting\n\n\nPlotting is done with the \nplot_network\n function.\n\n\njulia\n \nusing\n \nEcologicalNetwork\n\n\n\njulia\n \nN\n \n=\n \nbluthgen\n()\n\n\nEcologicalNetwork\n.\nBipartiteQuantiNetwork\n(\nNumber\n[\n1.0\n \n0.0\n \n\u2026\n \n0.0\n \n0.0\n;\n \n0.0\n \n0.0\n \n\u2026\n \n0.0\n \n0.0\n;\n \n\u2026\n \n;\n \n0.0\n \n0.0\n \n\u2026\n \n0.0\n \n1.0\n;\n \n0.0\n \n0.0\n \n\u2026\n \n0.0\n \n0.0\n])\n\n\n\njulia\n \nplot_network\n(\nN\n,\n \nfile\n=\nbluthgenDegree.png\n)\n\n\n\n\n\n\nThis is what the result should look like:\n\n\n\n\n\n\nPlotting modular networks\n\n\nPlotting modular networks is a special case, for which the \nplot_network\n function accepts an additional argument (a network \nPartition\n).\n\n\n\n\nAdditional information\n\n\n#\n\n\nEcologicalNetwork.plot_network\n \n \nFunction\n.\n\n\nDraw a network as a matrix to a png file. In the case of a quantitative or probabilistic network, nuances of grey indicate interaction strength.\n\n\nArguments:\n\n\n\n\nN::EcoNetwork\n, the network to draw\n\n\n\n\nKeywords:\n\n\n\n\norder::Symbol\n, either \n:none\n or \n:degree\n (default), the criteria to use to re-order nodes\n\n\ntransform::Function\n, the function to apply to every interaction (\nx -\n x\n by default, but can be \nsqrt\n, \nlog\n, ...)\n\n\nfile\n, the name of the file (with the \n.png\n extension) to write to\n\n\n\n\nsource\n\n\nDraw a network as a matrix to a png file, and respects the modules of every nodes. In the case of a quantitative or probabilistic network, nuances of grey indicate interaction strength.\n\n\nArguments:\n\n\n\n\nN::EcoNetwork\n, the network to draw\n\n\nP::Partition\n, the partition of the network\n\n\n\n\nKeywords:\n\n\n\n\norder::Symbol\n, either \n:none\n or \n:degree\n (default), the criteria to use to re-order nodes within modules\n\n\ntransform::Function\n, the function to apply to every interaction (\nx -\n x\n by default, but can be \nsqrt\n, \nlog\n, ...)\n\n\nfile\n, the name of the file (with the \n.png\n extension) to write to\n\n\n\n\nsource", 
            "title": "Plotting"
        }, 
        {
            "location": "/man/plotting/#plotting", 
            "text": "Plotting is done with the  plot_network  function.  julia   using   EcologicalNetwork  julia   N   =   bluthgen ()  EcologicalNetwork . BipartiteQuantiNetwork ( Number [ 1.0   0.0   \u2026   0.0   0.0 ;   0.0   0.0   \u2026   0.0   0.0 ;   \u2026   ;   0.0   0.0   \u2026   0.0   1.0 ;   0.0   0.0   \u2026   0.0   0.0 ])  julia   plot_network ( N ,   file = bluthgenDegree.png )   This is what the result should look like:", 
            "title": "Plotting"
        }, 
        {
            "location": "/man/plotting/#plotting-modular-networks", 
            "text": "Plotting modular networks is a special case, for which the  plot_network  function accepts an additional argument (a network  Partition ).", 
            "title": "Plotting modular networks"
        }, 
        {
            "location": "/man/plotting/#additional-information", 
            "text": "#  EcologicalNetwork.plot_network     Function .  Draw a network as a matrix to a png file. In the case of a quantitative or probabilistic network, nuances of grey indicate interaction strength.  Arguments:   N::EcoNetwork , the network to draw   Keywords:   order::Symbol , either  :none  or  :degree  (default), the criteria to use to re-order nodes  transform::Function , the function to apply to every interaction ( x -  x  by default, but can be  sqrt ,  log , ...)  file , the name of the file (with the  .png  extension) to write to   source  Draw a network as a matrix to a png file, and respects the modules of every nodes. In the case of a quantitative or probabilistic network, nuances of grey indicate interaction strength.  Arguments:   N::EcoNetwork , the network to draw  P::Partition , the partition of the network   Keywords:   order::Symbol , either  :none  or  :degree  (default), the criteria to use to re-order nodes within modules  transform::Function , the function to apply to every interaction ( x -  x  by default, but can be  sqrt ,  log , ...)  file , the name of the file (with the  .png  extension) to write to   source", 
            "title": "Additional information"
        }, 
        {
            "location": "/lib/public/", 
            "text": "Public Documentation\n\n\nDocumentation for EcologicalNetwork's public (exported) interface.\n\n\nSee \nInternal Documentation\n for documentation on internal functions.\n\n\n\n\nIndex\n\n\n\n\nEcologicalNetwork.Bipartite\n\n\nEcologicalNetwork.BipartiteNetwork\n\n\nEcologicalNetwork.BipartiteNetwork\n\n\nEcologicalNetwork.EcoNetwork\n\n\nEcologicalNetwork.Partition\n\n\nEcologicalNetwork.Partition\n\n\nEcologicalNetwork.Partition\n\n\nEcologicalNetwork.Unipartite\n\n\nEcologicalNetwork.UnipartiteNetwork\n\n\nEcologicalNetwork.UnipartiteNetwork\n\n\n\n\n\n\nFunctions\n\n\n\n\nTypes\n\n\n#\n\n\nEcologicalNetwork.Bipartite\n \n \nType\n.\n\n\nAll bipartite networks\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.BipartiteNetwork\n \n \nType\n.\n\n\nA bipartite deterministic network is a two-dimensional array of boolean values.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.BipartiteNetwork\n \n \nMethod\n.\n\n\nConstruct a bipartite network from a matrix of integer\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.EcoNetwork\n \n \nType\n.\n\n\nThis is an abstract type that allows to generate functions for all sorts of networks. All other types are derived from this one.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.Partition\n \n \nType\n.\n\n\nType to store a community partition\n\n\nThis type has three elements:\n\n\n\n\nN\n, the network\n\n\nL\n, the array of (integers) module labels\n\n\nQ\n, if needed, the modularity value\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.Partition\n \n \nMethod\n.\n\n\nConstructor for the \nPartition\n type from an \nEcoNetwork\n object and an array of module id.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.Partition\n \n \nMethod\n.\n\n\nConstructor for the \nPartition\n type from a \nEcoNetwork\n object.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.Unipartite\n \n \nType\n.\n\n\nAll unipartite networks\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.UnipartiteNetwork\n \n \nType\n.\n\n\nAn unipartite deterministic network.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.UnipartiteNetwork\n \n \nMethod\n.\n\n\nConstruct an unipartite network from a matrix of integer\n\n\nsource", 
            "title": "Public"
        }, 
        {
            "location": "/lib/public/#public-documentation", 
            "text": "Documentation for EcologicalNetwork's public (exported) interface.  See  Internal Documentation  for documentation on internal functions.", 
            "title": "Public Documentation"
        }, 
        {
            "location": "/lib/public/#index", 
            "text": "EcologicalNetwork.Bipartite  EcologicalNetwork.BipartiteNetwork  EcologicalNetwork.BipartiteNetwork  EcologicalNetwork.EcoNetwork  EcologicalNetwork.Partition  EcologicalNetwork.Partition  EcologicalNetwork.Partition  EcologicalNetwork.Unipartite  EcologicalNetwork.UnipartiteNetwork  EcologicalNetwork.UnipartiteNetwork", 
            "title": "Index"
        }, 
        {
            "location": "/lib/public/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/lib/public/#types", 
            "text": "#  EcologicalNetwork.Bipartite     Type .  All bipartite networks  source  #  EcologicalNetwork.BipartiteNetwork     Type .  A bipartite deterministic network is a two-dimensional array of boolean values.  source  #  EcologicalNetwork.BipartiteNetwork     Method .  Construct a bipartite network from a matrix of integer  source  #  EcologicalNetwork.EcoNetwork     Type .  This is an abstract type that allows to generate functions for all sorts of networks. All other types are derived from this one.  source  #  EcologicalNetwork.Partition     Type .  Type to store a community partition  This type has three elements:   N , the network  L , the array of (integers) module labels  Q , if needed, the modularity value   source  #  EcologicalNetwork.Partition     Method .  Constructor for the  Partition  type from an  EcoNetwork  object and an array of module id.  source  #  EcologicalNetwork.Partition     Method .  Constructor for the  Partition  type from a  EcoNetwork  object.  source  #  EcologicalNetwork.Unipartite     Type .  All unipartite networks  source  #  EcologicalNetwork.UnipartiteNetwork     Type .  An unipartite deterministic network.  source  #  EcologicalNetwork.UnipartiteNetwork     Method .  Construct an unipartite network from a matrix of integer  source", 
            "title": "Types"
        }, 
        {
            "location": "/lib/internals/", 
            "text": "Internal Documentation\n\n\nDocumentation for EcologicalNetwork's internal interface.\n\n\n\n\nIndex\n\n\n\n\nFunctions\n\n\n#\n\n\nEcologicalNetwork.Q\n \n \nMethod\n.\n\n\nThis measures modularity based on a matrix and a list of module labels. Note that this function assumes that interactions are directional, so that $A_{ij}$ represents an interaction from $i$ to $j$, but not the other way around.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.Q\n \n \nMethod\n.\n\n\nQ \u2013 a measure of modularity\n\n\nThis measures Barber's bipartite modularity based on a \nPartition\n object, and update the object in the proccess.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.Qr\n \n \nMethod\n.\n\n\nQr \u2013 a measure of realized modularity\n\n\nMeasures Poisot's realized modularity, based on a  a matrix and a list of module labels. Realized modularity takes values in the [0;1] interval, and is the proportion of interactions established \nwithin\n modules.\n\n\nNote that in some situations, \nQr\n can be \nlower\n than 0. This reflects a partition in which more links are established between than within modules.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.Qr\n \n \nMethod\n.\n\n\nQr \u2013 a measure of realized modularity\n\n\nMeasures Poisot's realized modularity, based on a \nPartition\n object.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.a_var\n \n \nMethod\n.\n\n\nVariance of a series of additive Bernoulli events\n\n\nf(p): \u2211(p(1-p))\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.adjacency\n \n \nMethod\n.\n\n\nReturns the adjaceny matrix of a non-deterministic network as a deterministic network.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.best_partition\n \n \nMethod\n.\n\n\nReturn the best partition out of a number of replicates. This returns an \narray\n of partitions. If there is a single partition maximizing the given function \nf\n (as a keyword), the results are \nstill\n returned as an array with a single element.\n\n\nArguments:\n\n\n\n\nmodpart::Array{Partition,1}\n, an array of partitions returned by \ne.g.\n \nmodularity\n\n\n\n\nKeywords:\n\n\n\n\nf::Function\n, either \nQ\n or \nQr\n (any function for which the highest value  represents a more modular structure).\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.betadiversity\n \n \nMethod\n.\n\n\nMeasure the expected network similarity\n\n\nNote that this is only meaningful to apply this function when the two matrices have the same species at the same position! If this is note the case, a \nBoundsError\n will be thrown.\n\n\nThis function will return a \nBetaSet\n, which is then used by the function to actually measure the beta-diversity. This package uses the approach of Koleff et a. (2003).\n\n\nReferences\n\n\n\n\nKoleff, P., Gaston, K. J. and Lennon, J. J. (2003), Measuring beta diversity\n\n\n\n\nfor presence\u2013absence data. Journal of Animal Ecology, 72: 367\u2013382. doi: 10.1046/j.1365-2656.2003.00710.x\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.bluthgen\n \n \nMethod\n.\n\n\nNumber of visits from Bluthgen et al XXX\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.centrality_katz\n \n \nMethod\n.\n\n\nMeasures Katz's centrality for each node in a unipartite network.\n\n\nKeyword arguments\n\n\n\n\na\n (def. 0.1), the weight of each subsequent connection\n\n\nk\n (def. 5), the maximal path length considered\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.connectance\n \n \nMethod\n.\n\n\nNumber of links divided by the number of possible interactions. In unipartite networks, this is $L/S^2$. In bipartite networks, this is $L/(T \u00d7 B)$.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.connectance\n \n \nMethod\n.\n\n\nConnectance of a quantitative network \u2013 the information on link weight is ignored.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.connectance_var\n \n \nMethod\n.\n\n\nExpected variance of the connectance for a probabilistic matrix, measured as the variance of the number of links divided by the squared size of the matrix.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.count_motifs\n \n \nMethod\n.\n\n\nMotif counter for a bipartite network\n\n\nThis function will go through all k-permutations of \nN\n to measure the probability of each induced subgraph being an instance of the motif given by \nm\n (the adjacency matrix of the motif, with 0 and 1). Note that the \nk\n is determined by the dimensions of \nn\n.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.count_motifs\n \n \nMethod\n.\n\n\nMotif counter for an unipartite network\n\n\nThis function will go through all k-permutations of \nN\n to measure the probability of each induced subgraph being an instance of the motif given by \nm\n (the adjacency matrix of the motif, with 0 and 1). Note that the \nk\n is determined by the dimensions of \nn\n.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.degree\n \n \nMethod\n.\n\n\nThis function returns the total degree of nodes in a bipartite network. This is a concatenation of the out degree and the in degrees of nodes on both sizes\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.degree\n \n \nMethod\n.\n\n\nThis function returns the sum of the in and out degree of a unipartite graph\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.degree_in\n \n \nMethod\n.\n\n\nExpected number of ingoing degrees.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.degree_out\n \n \nMethod\n.\n\n\nExpected number of outgoing degrees.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.free_species\n \n \nMethod\n.\n\n\nExpected number of species with no interactions\n\n\nThis function will be applied on the \nunipartite\n version of the network. Note that the functions \nspecies_ |predecessors\n will work on bipartite networks, but the unipartite situation is more general.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.gaston\n \n \nMethod\n.\n\n\nGaston measure of beta-diversity \n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.harrison\n \n \nMethod\n.\n\n\nHarrison measure of beta-diversity \n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.hartekinzig\n \n \nMethod\n.\n\n\nHarte-Kinzig measure of beta-diversity \n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.i_esp\n \n \nMethod\n.\n\n\nExpected value of a single Bernoulli event\n\n\nSimply f(p): p\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.i_var\n \n \nMethod\n.\n\n\nVariance of a single Bernoulli event\n\n\nf(p): p(1-p)\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.jaccard\n \n \nMethod\n.\n\n\nJaccard measure of beta-diversity \n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.label_propagation\n \n \nMethod\n.\n\n\nPerforms label propagation in an \nEcoNetwork\n.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.lande\n \n \nMethod\n.\n\n\nLande measure of beta-diversity \n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.link_number\n \n \nMethod\n.\n\n\nIn quantitative networks only, returns the number of non-zero interactions.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.linkage_density\n \n \nMethod\n.\n\n\nLinkage density\n\n\nNumber of links divided by species richness.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.links\n \n \nMethod\n.\n\n\nFor all type of networks, this is the sum of the adjacency matrix. Note that for quantitative networks, this is the cumulative sum of link weights.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.links_var\n \n \nMethod\n.\n\n\nExpected variance of the number of links for a probabilistic network\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.m_var\n \n \nMethod\n.\n\n\nVariance of a series of multiplicative Bernoulli events\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.make_bernoulli\n \n \nMethod\n.\n\n\nReturns a matrix B of the same size as A, in which each element B(i,j) is 1 with probability A(i,j).\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.make_binary\n \n \nMethod\n.\n\n\nReturns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is greater than 0.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.make_threshold\n \n \nMethod\n.\n\n\nReturns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is \n \nk\n. This is probably unwise to use this function since this practice is of questionnable relevance, but it is included for the sake of exhaustivity.\n\n\nk\n must be in [0;1[.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.make_unipartite\n \n \nMethod\n.\n\n\nTransforms a bipartite network into a unipartite network. Note that this function returns an asymetric unipartite network.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.mcmullen\n \n \nMethod\n.\n\n\nPlant-flower visitor interactions in the Galapagos.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.modularity\n \n \nMethod\n.\n\n\nThis function is a wrapper for the modularity code. The number of replicates is the number of times the modularity optimization should be run. By default, it uses \nlabel_propagation\n.\n\n\nArguments:\n\n\n\n\nN::EcoNetwork\n, the network to work on\n\n\nL::Array{Int64,1}\n, an array of module identities\n\n\n\n\nKeywords:\n\n\n\n\nreplicates::Int64\n, defaults to \n100\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.motif\n \n \nMethod\n.\n\n\nIn a network \nN\n, counts the number of time a motif \nm\n appears. In the case of a probabilistic network, \nN\n is the expected number of motifs. In the case of a quantitative network, \nN\n is the number of times the motif appears in the unweighted network.\n\n\nNote that because self-edges (\na.k.a.\n loops, or cannibalism) are \nnot\n counted in the motifs (the adjacency matrix is treated as if it had all diagonal elements set to 0).\n\n\nArguments:\n\n\n\n\nN::EcoNetwork\n, the network in which to count the motifs\n\n\nm::DeterministicNetwork\n, the adjacency matrix of the motif\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.motif_p\n \n \nMethod\n.\n\n\nProbability that a group of species form a given motif. This works for both the probabilistic and deterministic networks.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.motif_v\n \n \nMethod\n.\n\n\nVariance that a group of species form a given motif\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.motif_var\n \n \nMethod\n.\n\n\nExpected variance of a given motif \n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.nodf\n \n \nMethod\n.\n\n\nMeasures the Nestedness based on Overlap and Decreasing Fill. If the network is quantitative, then \nWNODF\n is measured instead of \nNODF\n. Note that in \nall\n situations, the value goes between 0 (not nested) to 1 (perfectly nested). This is a change with regard to the original papers, in which the maximal value is\n\n\n\n\nThe values returned are the nestedness of the network, of the columns, and\n\n\n\n\nof the rows.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.nodiag\n \n \nMethod\n.\n\n\nReturn a copy of a bipartite network with all diagonal elements set to the appropriate zero. You may yell \"This is stupid, the diagonal means nothing in a bipartite network, and it's also unlikely that they will be square anyways. Morons.\" Well, this is rude. This function will return the network \nunchanged\n.\n\n\n\"Then why do you need this function in the first place?\". We're glad you asked. Some functions work better if the networks have no diagonal elements, and it's better to have a function that does nothing, than a series of ifelses in these functions.\n\n\nAlso, we can read your thoughts. Always.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.nodiag\n \n \nMethod\n.\n\n\nReturns a copy of the network with all diagonal elements set to the the appropriate zero value. This means \nfalse\n for deterministic networks, and 0.0 for all other networks.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null1\n \n \nMethod\n.\n\n\nGiven a matrix \nA\n, \nnull1(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the connectance of \nA\n.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null2\n \n \nMethod\n.\n\n\nGiven a matrix \nA\n, \nnull2(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the degree of each species.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null3in\n \n \nMethod\n.\n\n\nGiven a matrix \nA\n, \nnull3in(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the in-degree (number of predecessors) of each species, divided by the total number of possible predecessors.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null3out\n \n \nMethod\n.\n\n\nGiven a matrix \nA\n, \nnull3out(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the out-degree (number of successors) of each species, divided by the total number of possible successors.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.nullmodel\n \n \nMethod\n.\n\n\nThis function is a wrapper to generate replicated binary matrices from a template probability matrix \nA\n.\n\n\nIf you use julia on more than one CPU, \ni.e.\n if you started it with \njulia -p k\n where \nk\n is more than 1, this function will distribute each trial to one worker. Which means that it's fast.\n\n\nKeyword arguments\n\n\n\n\nn\n (def. 1000), number of replicates to generate\n\n\nmax\n (def. 10000), number of trials to make\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.number_of_paths\n \n \nMethod\n.\n\n\nNumber of paths of length n between all pairs of nodes\n\n\nThis returns an array, not a network.\n\n\nKeyword arguments\n\n\n\n\nn\n (def. 2), the path length\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.ollerton\n \n \nMethod\n.\n\n\nFish-anemone interactions from Ollerton et al. 2007\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.plot_network\n \n \nMethod\n.\n\n\nDraw a network as a matrix to a png file, and respects the modules of every nodes. In the case of a quantitative or probabilistic network, nuances of grey indicate interaction strength.\n\n\nArguments:\n\n\n\n\nN::EcoNetwork\n, the network to draw\n\n\nP::Partition\n, the partition of the network\n\n\n\n\nKeywords:\n\n\n\n\norder::Symbol\n, either \n:none\n or \n:degree\n (default), the criteria to use to re-order nodes within modules\n\n\ntransform::Function\n, the function to apply to every interaction (\nx -\n x\n by default, but can be \nsqrt\n, \nlog\n, ...)\n\n\nfile\n, the name of the file (with the \n.png\n extension) to write to\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.plot_network\n \n \nMethod\n.\n\n\nDraw a network as a matrix to a png file. In the case of a quantitative or probabilistic network, nuances of grey indicate interaction strength.\n\n\nArguments:\n\n\n\n\nN::EcoNetwork\n, the network to draw\n\n\n\n\nKeywords:\n\n\n\n\norder::Symbol\n, either \n:none\n or \n:degree\n (default), the criteria to use to re-order nodes\n\n\ntransform::Function\n, the function to apply to every interaction (\nx -\n x\n by default, but can be \nsqrt\n, \nlog\n, ...)\n\n\nfile\n, the name of the file (with the \n.png\n extension) to write to\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.richness\n \n \nMethod\n.\n\n\nRichness (number of species) in a bipartite network\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.richness\n \n \nMethod\n.\n\n\nRichness (number of species) in a unipartite network\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.robertson\n \n \nMethod\n.\n\n\nPollination interaction from Robertson 1927, in an agricultural area dominated by crops, with some natural forest and pasture.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.ruggiero\n \n \nMethod\n.\n\n\nRuggiero measure of beta-diversity \n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.sorensen\n \n \nMethod\n.\n\n\nSorensen measure of beta-diversity \n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.species_has_no_predecessors\n \n \nMethod\n.\n\n\nProbability that a species has no predecessors\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.species_has_no_successors\n \n \nMethod\n.\n\n\nProbability that a species has no successors\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.species_is_free\n \n \nMethod\n.\n\n\nProbability that a species has no links\n\n\nThis will return a vector, where the \ni\nth element is the probability that species \ni\n has no interaction. Note that this is only meaningful for unipartite networks.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.specificity\n \n \nMethod\n.\n\n\nResource-range measure of specificity in deterministic networks.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.specificity\n \n \nMethod\n.\n\n\nPaired Differences Index of specificity in quantitative networks.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.stony\n \n \nMethod\n.\n\n\nStony food web from Thompson \n Townsend. This was sampled in a tussock grassland near Otago, New Zealand.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.swaps\n \n \nMethod\n.\n\n\nGenerates randomized networks based on some constraints on degre distributions.\n\n\nBy default, this method will look for random (x, x) sub-matrices, where x is given by the \nswapsize\n keyword, and shuffle them. There are four possible constraints:\n\n\n\n\n\n\n\n\nvalue\n\n\nmeaning\n\n\nproba equivalent\n\n\n\n\n\n\n\n\n\n\n:degree\n\n\nboth in and out degree\n\n\nnull2\n\n\n\n\n\n\n:generality\n\n\nonly out degree\n\n\nnull3out\n\n\n\n\n\n\n:vulnerability\n\n\nonly in degree\n\n\nnull3in\n\n\n\n\n\n\n:fill\n\n\nonly number of links\n\n\nnull1\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nN\n, a \nDeterministicNetwork\n\n\nr\n, the number of randomized networks to generate\n\n\n\n\nKeywords:\n\n\n\n\nconstraint\n: can be \n:degree\n, \n:generality\n, \n:vulnerability\n, or \n:fill\n\n\nswapsize\n: the size of the square sub-matrix to swap (defaults to 3)\n\n\nn\n: the number of sub-matrices to swap (defaults to 3000)\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.test_network_property\n \n \nMethod\n.\n\n\nTest a network property using randomizations based on a null model, from a pre-existing collection of networks.\n\n\nArguments:\n\n\n\n\nN\n \u2013 the original network\n\n\nf\n \u2013 the function to test, must return a single floating point value\n\n\nS\n \u2013 an array of randomized networks (\ne.g.\n the output of \nnullmodel\n)\n\n\n\n\nKeywords:\n\n\n\n\ntest\n \u2013 the type of test to perform (\n:smaller\n or \n:greater\n)\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.unipartitemotifs\n \n \nMethod\n.\n\n\nReturns a dictionary of the usual unipartite motifs. The names of the motifs come from Stouffer et al. (2007) \u2013 especially Fig. 1, available online at \nhttp://rspb.royalsocietypublishing.org/content/274/1621/1931.figures-only\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.whittaker\n \n \nMethod\n.\n\n\nWhittaker measure of beta-diversity \n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.williams\n \n \nMethod\n.\n\n\nWilliams measure of beta-diversity \n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.woods\n \n \nMethod\n.\n\n\nLake of the Woods host-parasite data. Interactions content are prevalence.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.\u03b7\n \n \nMethod\n.\n\n\nNestedness of a matrix, using the Bastolla et al. (XXXX) measure\n\n\nReturns three values:\n\n\n\n\nnestedness of the entire matrix\n\n\nnestedness of the columns\n\n\nnestedness of the rows\n\n\n\n\nsource\n\n\n#\n\n\nBase.copy\n \n \nMethod\n.\n\n\nCreates a copy of a network \u2013 this returns an object with the same type, and the same content.\n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\nGetindex custom to get interaction value from an EcoNetwork\n\n\nsource\n\n\n#\n\n\nBase.setindex!\n \n \nMethod\n.\n\n\nSetindex for EcoNetwork\n\n\nsource\n\n\n#\n\n\nBase.size\n \n \nMethod\n.\n\n\nReturn the size of the adjacency matrix of an EcoNetwork object.\n\n\nsource\n\n\n#\n\n\nBase.transpose\n \n \nMethod\n.\n\n\nReturn a transposed network with the correct type\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.delta_matrix\n \n \nMethod\n.\n\n\nGet the \u03b4 matrix, representing whether two nodes are part of the same module.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.draw_matrix\n \n \nMethod\n.\n\n\nLow-level function to draw the network.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.inner_swap\n \n \nMethod\n.\n\n\nPerforms an inner swap\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.is_valid\n \n \nMethod\n.\n\n\nThis function will take two matrices and one constraint, and return whether the first matrix is a valid permutation of the second one under a given constraint.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.most_common_label\n \n \nMethod\n.\n\n\nCount most common labels\n\n\nArguments are the network, the community partition, and the species id\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.most_common_label\n \n \nMethod\n.\n\n\nCount most common labels\n\n\nArguments are the network, the community partition, and the species id\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.most_common_label\n \n \nMethod\n.\n\n\nCount most common labels\n\n\nArguments are the network, the community partition, and the species id\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.motif_internal!\n \n \nMethod\n.\n\n\nInternal motif calculations\n\n\nThe two arguments are \nN\n the network and \nm\n the motif adjacency matrix (as a \nDeterministicNetwork\n). The two matrices must have the same size.  The function returns a \nvectorized\n probability of each interaction being in the right state for the motif, \ni.e.\n P if m is 1, and 1 - P if m is 0.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.nodf_axis\n \n \nMethod\n.\n\n\nNODF of a single axis\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.pdi\n \n \nMethod\n.\n\n\nPaired Differences Index for specificity. This function will range the values of each row, so that the strongest link has a value of one.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.permute_network\n \n \nMethod\n.\n\n\nTake a bipartite network, returns a collection of unique permutations\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.permute_network\n \n \nMethod\n.\n\n\nTake a unipartite network, returns a collection of unique permutations\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.soilphagebacteria\n \n \nFunction\n.\n\n\nSoil-isolated phage-bacteria networks. Interactions are the impact of phage on the bacteria.\n\n\nhttps://figshare.com/articles/Phage_bacteria_networks_isolated_in_soil/696102\n\n\nTakes a positional argument \ni\n, indicating which network (from 1 to 5) to return.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.swap\n \n \nMethod\n.\n\n\nSwaps a bipartite network while enforcing a constraint on degree distribution.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.swap\n \n \nMethod\n.\n\n\nSwaps a unipartite network while enforcing a constraint on degree distribution.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.wnodf_axis\n \n \nMethod\n.\n\n\nWNODF of a single axis\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.\u03b7_axis\n \n \nMethod\n.\n\n\nNestedness of a single axis (called internally by \n\u03b7\n)\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.@checkprob\n \n \nMacro\n.\n\n\nQuite crude way of checking that a number is a probability\n\n\nThe two steps are\n\n\n\n\nThe number should be of the \nFloat64\n type \u2013 if not, will yield a \nTypeError\n\n\nThe number should belong to [0,1] \u2013 if not, will throw a \nDomainError\n\n\n\n\nsource", 
            "title": "Internals"
        }, 
        {
            "location": "/lib/internals/#internal-documentation", 
            "text": "Documentation for EcologicalNetwork's internal interface.", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/lib/internals/#index", 
            "text": "", 
            "title": "Index"
        }, 
        {
            "location": "/lib/internals/#functions", 
            "text": "#  EcologicalNetwork.Q     Method .  This measures modularity based on a matrix and a list of module labels. Note that this function assumes that interactions are directional, so that $A_{ij}$ represents an interaction from $i$ to $j$, but not the other way around.  source  #  EcologicalNetwork.Q     Method .  Q \u2013 a measure of modularity  This measures Barber's bipartite modularity based on a  Partition  object, and update the object in the proccess.  source  #  EcologicalNetwork.Qr     Method .  Qr \u2013 a measure of realized modularity  Measures Poisot's realized modularity, based on a  a matrix and a list of module labels. Realized modularity takes values in the [0;1] interval, and is the proportion of interactions established  within  modules.  Note that in some situations,  Qr  can be  lower  than 0. This reflects a partition in which more links are established between than within modules.  source  #  EcologicalNetwork.Qr     Method .  Qr \u2013 a measure of realized modularity  Measures Poisot's realized modularity, based on a  Partition  object.  source  #  EcologicalNetwork.a_var     Method .  Variance of a series of additive Bernoulli events  f(p): \u2211(p(1-p))  source  #  EcologicalNetwork.adjacency     Method .  Returns the adjaceny matrix of a non-deterministic network as a deterministic network.  source  #  EcologicalNetwork.best_partition     Method .  Return the best partition out of a number of replicates. This returns an  array  of partitions. If there is a single partition maximizing the given function  f  (as a keyword), the results are  still  returned as an array with a single element.  Arguments:   modpart::Array{Partition,1} , an array of partitions returned by  e.g.   modularity   Keywords:   f::Function , either  Q  or  Qr  (any function for which the highest value  represents a more modular structure).   source  #  EcologicalNetwork.betadiversity     Method .  Measure the expected network similarity  Note that this is only meaningful to apply this function when the two matrices have the same species at the same position! If this is note the case, a  BoundsError  will be thrown.  This function will return a  BetaSet , which is then used by the function to actually measure the beta-diversity. This package uses the approach of Koleff et a. (2003).  References   Koleff, P., Gaston, K. J. and Lennon, J. J. (2003), Measuring beta diversity   for presence\u2013absence data. Journal of Animal Ecology, 72: 367\u2013382. doi: 10.1046/j.1365-2656.2003.00710.x  source  #  EcologicalNetwork.bluthgen     Method .  Number of visits from Bluthgen et al XXX  source  #  EcologicalNetwork.centrality_katz     Method .  Measures Katz's centrality for each node in a unipartite network.  Keyword arguments   a  (def. 0.1), the weight of each subsequent connection  k  (def. 5), the maximal path length considered   source  #  EcologicalNetwork.connectance     Method .  Number of links divided by the number of possible interactions. In unipartite networks, this is $L/S^2$. In bipartite networks, this is $L/(T \u00d7 B)$.  source  #  EcologicalNetwork.connectance     Method .  Connectance of a quantitative network \u2013 the information on link weight is ignored.  source  #  EcologicalNetwork.connectance_var     Method .  Expected variance of the connectance for a probabilistic matrix, measured as the variance of the number of links divided by the squared size of the matrix.  source  #  EcologicalNetwork.count_motifs     Method .  Motif counter for a bipartite network  This function will go through all k-permutations of  N  to measure the probability of each induced subgraph being an instance of the motif given by  m  (the adjacency matrix of the motif, with 0 and 1). Note that the  k  is determined by the dimensions of  n .  source  #  EcologicalNetwork.count_motifs     Method .  Motif counter for an unipartite network  This function will go through all k-permutations of  N  to measure the probability of each induced subgraph being an instance of the motif given by  m  (the adjacency matrix of the motif, with 0 and 1). Note that the  k  is determined by the dimensions of  n .  source  #  EcologicalNetwork.degree     Method .  This function returns the total degree of nodes in a bipartite network. This is a concatenation of the out degree and the in degrees of nodes on both sizes  source  #  EcologicalNetwork.degree     Method .  This function returns the sum of the in and out degree of a unipartite graph  source  #  EcologicalNetwork.degree_in     Method .  Expected number of ingoing degrees.  source  #  EcologicalNetwork.degree_out     Method .  Expected number of outgoing degrees.  source  #  EcologicalNetwork.free_species     Method .  Expected number of species with no interactions  This function will be applied on the  unipartite  version of the network. Note that the functions  species_ |predecessors  will work on bipartite networks, but the unipartite situation is more general.  source  #  EcologicalNetwork.gaston     Method .  Gaston measure of beta-diversity   source  #  EcologicalNetwork.harrison     Method .  Harrison measure of beta-diversity   source  #  EcologicalNetwork.hartekinzig     Method .  Harte-Kinzig measure of beta-diversity   source  #  EcologicalNetwork.i_esp     Method .  Expected value of a single Bernoulli event  Simply f(p): p  source  #  EcologicalNetwork.i_var     Method .  Variance of a single Bernoulli event  f(p): p(1-p)  source  #  EcologicalNetwork.jaccard     Method .  Jaccard measure of beta-diversity   source  #  EcologicalNetwork.label_propagation     Method .  Performs label propagation in an  EcoNetwork .  source  #  EcologicalNetwork.lande     Method .  Lande measure of beta-diversity   source  #  EcologicalNetwork.link_number     Method .  In quantitative networks only, returns the number of non-zero interactions.  source  #  EcologicalNetwork.linkage_density     Method .  Linkage density  Number of links divided by species richness.  source  #  EcologicalNetwork.links     Method .  For all type of networks, this is the sum of the adjacency matrix. Note that for quantitative networks, this is the cumulative sum of link weights.  source  #  EcologicalNetwork.links_var     Method .  Expected variance of the number of links for a probabilistic network  source  #  EcologicalNetwork.m_var     Method .  Variance of a series of multiplicative Bernoulli events  source  #  EcologicalNetwork.make_bernoulli     Method .  Returns a matrix B of the same size as A, in which each element B(i,j) is 1 with probability A(i,j).  source  #  EcologicalNetwork.make_binary     Method .  Returns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is greater than 0.  source  #  EcologicalNetwork.make_threshold     Method .  Returns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is    k . This is probably unwise to use this function since this practice is of questionnable relevance, but it is included for the sake of exhaustivity.  k  must be in [0;1[.  source  #  EcologicalNetwork.make_unipartite     Method .  Transforms a bipartite network into a unipartite network. Note that this function returns an asymetric unipartite network.  source  #  EcologicalNetwork.mcmullen     Method .  Plant-flower visitor interactions in the Galapagos.  source  #  EcologicalNetwork.modularity     Method .  This function is a wrapper for the modularity code. The number of replicates is the number of times the modularity optimization should be run. By default, it uses  label_propagation .  Arguments:   N::EcoNetwork , the network to work on  L::Array{Int64,1} , an array of module identities   Keywords:   replicates::Int64 , defaults to  100   source  #  EcologicalNetwork.motif     Method .  In a network  N , counts the number of time a motif  m  appears. In the case of a probabilistic network,  N  is the expected number of motifs. In the case of a quantitative network,  N  is the number of times the motif appears in the unweighted network.  Note that because self-edges ( a.k.a.  loops, or cannibalism) are  not  counted in the motifs (the adjacency matrix is treated as if it had all diagonal elements set to 0).  Arguments:   N::EcoNetwork , the network in which to count the motifs  m::DeterministicNetwork , the adjacency matrix of the motif   source  #  EcologicalNetwork.motif_p     Method .  Probability that a group of species form a given motif. This works for both the probabilistic and deterministic networks.  source  #  EcologicalNetwork.motif_v     Method .  Variance that a group of species form a given motif  source  #  EcologicalNetwork.motif_var     Method .  Expected variance of a given motif   source  #  EcologicalNetwork.nodf     Method .  Measures the Nestedness based on Overlap and Decreasing Fill. If the network is quantitative, then  WNODF  is measured instead of  NODF . Note that in  all  situations, the value goes between 0 (not nested) to 1 (perfectly nested). This is a change with regard to the original papers, in which the maximal value is   The values returned are the nestedness of the network, of the columns, and   of the rows.  source  #  EcologicalNetwork.nodiag     Method .  Return a copy of a bipartite network with all diagonal elements set to the appropriate zero. You may yell \"This is stupid, the diagonal means nothing in a bipartite network, and it's also unlikely that they will be square anyways. Morons.\" Well, this is rude. This function will return the network  unchanged .  \"Then why do you need this function in the first place?\". We're glad you asked. Some functions work better if the networks have no diagonal elements, and it's better to have a function that does nothing, than a series of ifelses in these functions.  Also, we can read your thoughts. Always.  source  #  EcologicalNetwork.nodiag     Method .  Returns a copy of the network with all diagonal elements set to the the appropriate zero value. This means  false  for deterministic networks, and 0.0 for all other networks.  source  #  EcologicalNetwork.null1     Method .  Given a matrix  A ,  null1(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the connectance of  A .  source  #  EcologicalNetwork.null2     Method .  Given a matrix  A ,  null2(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the degree of each species.  source  #  EcologicalNetwork.null3in     Method .  Given a matrix  A ,  null3in(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the in-degree (number of predecessors) of each species, divided by the total number of possible predecessors.  source  #  EcologicalNetwork.null3out     Method .  Given a matrix  A ,  null3out(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the out-degree (number of successors) of each species, divided by the total number of possible successors.  source  #  EcologicalNetwork.nullmodel     Method .  This function is a wrapper to generate replicated binary matrices from a template probability matrix  A .  If you use julia on more than one CPU,  i.e.  if you started it with  julia -p k  where  k  is more than 1, this function will distribute each trial to one worker. Which means that it's fast.  Keyword arguments   n  (def. 1000), number of replicates to generate  max  (def. 10000), number of trials to make   source  #  EcologicalNetwork.number_of_paths     Method .  Number of paths of length n between all pairs of nodes  This returns an array, not a network.  Keyword arguments   n  (def. 2), the path length   source  #  EcologicalNetwork.ollerton     Method .  Fish-anemone interactions from Ollerton et al. 2007  source  #  EcologicalNetwork.plot_network     Method .  Draw a network as a matrix to a png file, and respects the modules of every nodes. In the case of a quantitative or probabilistic network, nuances of grey indicate interaction strength.  Arguments:   N::EcoNetwork , the network to draw  P::Partition , the partition of the network   Keywords:   order::Symbol , either  :none  or  :degree  (default), the criteria to use to re-order nodes within modules  transform::Function , the function to apply to every interaction ( x -  x  by default, but can be  sqrt ,  log , ...)  file , the name of the file (with the  .png  extension) to write to   source  #  EcologicalNetwork.plot_network     Method .  Draw a network as a matrix to a png file. In the case of a quantitative or probabilistic network, nuances of grey indicate interaction strength.  Arguments:   N::EcoNetwork , the network to draw   Keywords:   order::Symbol , either  :none  or  :degree  (default), the criteria to use to re-order nodes  transform::Function , the function to apply to every interaction ( x -  x  by default, but can be  sqrt ,  log , ...)  file , the name of the file (with the  .png  extension) to write to   source  #  EcologicalNetwork.richness     Method .  Richness (number of species) in a bipartite network  source  #  EcologicalNetwork.richness     Method .  Richness (number of species) in a unipartite network  source  #  EcologicalNetwork.robertson     Method .  Pollination interaction from Robertson 1927, in an agricultural area dominated by crops, with some natural forest and pasture.  source  #  EcologicalNetwork.ruggiero     Method .  Ruggiero measure of beta-diversity   source  #  EcologicalNetwork.sorensen     Method .  Sorensen measure of beta-diversity   source  #  EcologicalNetwork.species_has_no_predecessors     Method .  Probability that a species has no predecessors  source  #  EcologicalNetwork.species_has_no_successors     Method .  Probability that a species has no successors  source  #  EcologicalNetwork.species_is_free     Method .  Probability that a species has no links  This will return a vector, where the  i th element is the probability that species  i  has no interaction. Note that this is only meaningful for unipartite networks.  source  #  EcologicalNetwork.specificity     Method .  Resource-range measure of specificity in deterministic networks.  source  #  EcologicalNetwork.specificity     Method .  Paired Differences Index of specificity in quantitative networks.  source  #  EcologicalNetwork.stony     Method .  Stony food web from Thompson   Townsend. This was sampled in a tussock grassland near Otago, New Zealand.  source  #  EcologicalNetwork.swaps     Method .  Generates randomized networks based on some constraints on degre distributions.  By default, this method will look for random (x, x) sub-matrices, where x is given by the  swapsize  keyword, and shuffle them. There are four possible constraints:     value  meaning  proba equivalent      :degree  both in and out degree  null2    :generality  only out degree  null3out    :vulnerability  only in degree  null3in    :fill  only number of links  null1     Arguments:   N , a  DeterministicNetwork  r , the number of randomized networks to generate   Keywords:   constraint : can be  :degree ,  :generality ,  :vulnerability , or  :fill  swapsize : the size of the square sub-matrix to swap (defaults to 3)  n : the number of sub-matrices to swap (defaults to 3000)   source  #  EcologicalNetwork.test_network_property     Method .  Test a network property using randomizations based on a null model, from a pre-existing collection of networks.  Arguments:   N  \u2013 the original network  f  \u2013 the function to test, must return a single floating point value  S  \u2013 an array of randomized networks ( e.g.  the output of  nullmodel )   Keywords:   test  \u2013 the type of test to perform ( :smaller  or  :greater )   source  #  EcologicalNetwork.unipartitemotifs     Method .  Returns a dictionary of the usual unipartite motifs. The names of the motifs come from Stouffer et al. (2007) \u2013 especially Fig. 1, available online at  http://rspb.royalsocietypublishing.org/content/274/1621/1931.figures-only  source  #  EcologicalNetwork.whittaker     Method .  Whittaker measure of beta-diversity   source  #  EcologicalNetwork.williams     Method .  Williams measure of beta-diversity   source  #  EcologicalNetwork.woods     Method .  Lake of the Woods host-parasite data. Interactions content are prevalence.  source  #  EcologicalNetwork.\u03b7     Method .  Nestedness of a matrix, using the Bastolla et al. (XXXX) measure  Returns three values:   nestedness of the entire matrix  nestedness of the columns  nestedness of the rows   source  #  Base.copy     Method .  Creates a copy of a network \u2013 this returns an object with the same type, and the same content.  source  #  Base.getindex     Method .  Getindex custom to get interaction value from an EcoNetwork  source  #  Base.setindex!     Method .  Setindex for EcoNetwork  source  #  Base.size     Method .  Return the size of the adjacency matrix of an EcoNetwork object.  source  #  Base.transpose     Method .  Return a transposed network with the correct type  source  #  EcologicalNetwork.delta_matrix     Method .  Get the \u03b4 matrix, representing whether two nodes are part of the same module.  source  #  EcologicalNetwork.draw_matrix     Method .  Low-level function to draw the network.  source  #  EcologicalNetwork.inner_swap     Method .  Performs an inner swap  source  #  EcologicalNetwork.is_valid     Method .  This function will take two matrices and one constraint, and return whether the first matrix is a valid permutation of the second one under a given constraint.  source  #  EcologicalNetwork.most_common_label     Method .  Count most common labels  Arguments are the network, the community partition, and the species id  source  #  EcologicalNetwork.most_common_label     Method .  Count most common labels  Arguments are the network, the community partition, and the species id  source  #  EcologicalNetwork.most_common_label     Method .  Count most common labels  Arguments are the network, the community partition, and the species id  source  #  EcologicalNetwork.motif_internal!     Method .  Internal motif calculations  The two arguments are  N  the network and  m  the motif adjacency matrix (as a  DeterministicNetwork ). The two matrices must have the same size.  The function returns a  vectorized  probability of each interaction being in the right state for the motif,  i.e.  P if m is 1, and 1 - P if m is 0.  source  #  EcologicalNetwork.nodf_axis     Method .  NODF of a single axis  source  #  EcologicalNetwork.pdi     Method .  Paired Differences Index for specificity. This function will range the values of each row, so that the strongest link has a value of one.  source  #  EcologicalNetwork.permute_network     Method .  Take a bipartite network, returns a collection of unique permutations  source  #  EcologicalNetwork.permute_network     Method .  Take a unipartite network, returns a collection of unique permutations  source  #  EcologicalNetwork.soilphagebacteria     Function .  Soil-isolated phage-bacteria networks. Interactions are the impact of phage on the bacteria.  https://figshare.com/articles/Phage_bacteria_networks_isolated_in_soil/696102  Takes a positional argument  i , indicating which network (from 1 to 5) to return.  source  #  EcologicalNetwork.swap     Method .  Swaps a bipartite network while enforcing a constraint on degree distribution.  source  #  EcologicalNetwork.swap     Method .  Swaps a unipartite network while enforcing a constraint on degree distribution.  source  #  EcologicalNetwork.wnodf_axis     Method .  WNODF of a single axis  source  #  EcologicalNetwork.\u03b7_axis     Method .  Nestedness of a single axis (called internally by  \u03b7 )  source  #  EcologicalNetwork.@checkprob     Macro .  Quite crude way of checking that a number is a probability  The two steps are   The number should be of the  Float64  type \u2013 if not, will yield a  TypeError  The number should belong to [0,1] \u2013 if not, will throw a  DomainError   source", 
            "title": "Functions"
        }
    ]
}