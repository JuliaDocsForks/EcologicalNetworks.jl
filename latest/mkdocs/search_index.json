{
    "docs": [
        {
            "location": "/", 
            "text": "Analysis of ecological networks\n\n\nThe \nEcologicalNetwork\n package offers a convenient interface to analyse several types of ecological networks.\n\n\n\n\nOverview of features\n\n\n\n\nNetwork types", 
            "title": "Home"
        }, 
        {
            "location": "/#analysis-of-ecological-networks", 
            "text": "The  EcologicalNetwork  package offers a convenient interface to analyse several types of ecological networks.", 
            "title": "Analysis of ecological networks"
        }, 
        {
            "location": "/#overview-of-features", 
            "text": "", 
            "title": "Overview of features"
        }, 
        {
            "location": "/#network-types", 
            "text": "", 
            "title": "Network types"
        }, 
        {
            "location": "/types/", 
            "text": "Informations about types\n\n\nAs there are many ways to represent ecological networks, and the correct way to measure a given property varies in function of the representation, \nEcologicalNetwork\n has a series of built-in types.\n\n\n\n\nType hierarchy\n\n\nThe \nEcologicalNetwork\n package has four main types that are meant to be used by the user: \nBipartiteNetwork\n, \nBipartiteProbaNetwork\n, \nUnipartiteNetwork\n, and \nUnipartiteProbaNetwork\n. All types with \nProba\n in their names are meant to represent probabilistic networks, and are also part of the union type \nProbabilisticNetwork\n. All types \nwithout\n \nProba\n in their name are part of the union type \nDeterministicNetwork\n, and represent networks in which interactions are either present or absent. All types starting with \nBipartite\n are also part of the abstract type \nBipartite\n, and types with \nUnipartite\n in their names are part of the abstract type \nUnipartite\n. Finally, both \nUnipartite\n and \nBipartite\n are part of the abstract type \nEcoNetwork\n.\n\n\nAlthough this may seem convoluted, this is important to understand: when writing functions, you can restrict them to any type of network you want by using the right type in their declaration. You can also check properties of a network just by looking at its type. For example, one can check whether a network \nN\n is bipartite with:\n\n\ntypeof(N) \n: Bipartite\n\n\n\n\nNetworks are represented as two-dimensional matrices. All types are simply wrappers around an adjacency matrix, stored as the \nA\n property of the object. To look at the adjacency matrix of a network \nN\n, one therefore uses \nN.A\n. These matrices must be read as: the existence/probability of an interaction \nfrom\n the species of the \ni\n-th row \nto\n the species in the \nj\n-th column. This implies that the networks are, by default, directed.\n\n\n\n\nData types\n\n\nInteractions in deterministic networks are represented as boolean (\ntrue\n/\nfalse\n) values. This is memory efficient, so large networks can be represented (one interactions represented as a boolean uses 8 times fewer memory than the same interaction represented as an integer). This being said, all networks of the \nDeterministicNetwork\n type can be read from matrices of integers, \nas long as these matrices only contain 0 and 1\n.\n\n\nIn probabilistic networks, interactions are stored as floating point (\nFloat64\n) numbers. These values have to be between 0.0 and 1.0, as they represent probabilities.\n\n\nNetworks of the \nUnipartite\n class must have the same number of rows and columns. The species in the rows and columns are the same. Networks of the \nBipartite\n class are expected to have different numbers of rows and columns, as the species in rows and columns are different species. It is possible to convert a network from \nBipartite\n to \nUnipartite\n using the \nmake_unipartite\n function:\n\n\nB = BipartiteNetwork(rand(Bool, (3, 5)))\nrichnes(B) # 8\nU = make_unipartite(B)\nrichness(U) # 8\n\n\n\n\nThe documentation for \nmake_unipartite\n gives additional explanations about how the conversion is done. In the overwhelming majority of cases, applying any measure to a bipartite network, and to the same network made unipartite, should give the same results (connectance is one notable example).\n\n\n\n\nType reference\n\n\n#\n\n\nEcologicalNetwork.Bipartite\n \n \nType\n.\n\n\nBipartite type\n\n\nAll bipartite networks\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.BipartiteNetwork\n \n \nType\n.\n\n\nBipartiteNetwork\n\n\nA bipartite deterministic network.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.BipartiteNetwork\n \n \nMethod\n.\n\n\nConstruct a bipartite network from a matrix of integer\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.EcoNetwork\n \n \nType\n.\n\n\nEcoNetwork type\n\n\nThis is an abstract type that allows to generate functions for all sorts of networks. All other types are derived from this one.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.Unipartite\n \n \nType\n.\n\n\nUnipartite type\n\n\nAll unipartite networks\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.UnipartiteNetwork\n \n \nType\n.\n\n\nUnipartiteNetwork\n\n\nAn unipartite deterministic network.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.UnipartiteNetwork\n \n \nMethod\n.\n\n\nConstruct an unipartite network from a matrix of integer\n\n\nsource", 
            "title": "Types"
        }, 
        {
            "location": "/types/#informations-about-types", 
            "text": "As there are many ways to represent ecological networks, and the correct way to measure a given property varies in function of the representation,  EcologicalNetwork  has a series of built-in types.", 
            "title": "Informations about types"
        }, 
        {
            "location": "/types/#type-hierarchy", 
            "text": "The  EcologicalNetwork  package has four main types that are meant to be used by the user:  BipartiteNetwork ,  BipartiteProbaNetwork ,  UnipartiteNetwork , and  UnipartiteProbaNetwork . All types with  Proba  in their names are meant to represent probabilistic networks, and are also part of the union type  ProbabilisticNetwork . All types  without   Proba  in their name are part of the union type  DeterministicNetwork , and represent networks in which interactions are either present or absent. All types starting with  Bipartite  are also part of the abstract type  Bipartite , and types with  Unipartite  in their names are part of the abstract type  Unipartite . Finally, both  Unipartite  and  Bipartite  are part of the abstract type  EcoNetwork .  Although this may seem convoluted, this is important to understand: when writing functions, you can restrict them to any type of network you want by using the right type in their declaration. You can also check properties of a network just by looking at its type. For example, one can check whether a network  N  is bipartite with:  typeof(N)  : Bipartite  Networks are represented as two-dimensional matrices. All types are simply wrappers around an adjacency matrix, stored as the  A  property of the object. To look at the adjacency matrix of a network  N , one therefore uses  N.A . These matrices must be read as: the existence/probability of an interaction  from  the species of the  i -th row  to  the species in the  j -th column. This implies that the networks are, by default, directed.", 
            "title": "Type hierarchy"
        }, 
        {
            "location": "/types/#data-types", 
            "text": "Interactions in deterministic networks are represented as boolean ( true / false ) values. This is memory efficient, so large networks can be represented (one interactions represented as a boolean uses 8 times fewer memory than the same interaction represented as an integer). This being said, all networks of the  DeterministicNetwork  type can be read from matrices of integers,  as long as these matrices only contain 0 and 1 .  In probabilistic networks, interactions are stored as floating point ( Float64 ) numbers. These values have to be between 0.0 and 1.0, as they represent probabilities.  Networks of the  Unipartite  class must have the same number of rows and columns. The species in the rows and columns are the same. Networks of the  Bipartite  class are expected to have different numbers of rows and columns, as the species in rows and columns are different species. It is possible to convert a network from  Bipartite  to  Unipartite  using the  make_unipartite  function:  B = BipartiteNetwork(rand(Bool, (3, 5)))\nrichnes(B) # 8\nU = make_unipartite(B)\nrichness(U) # 8  The documentation for  make_unipartite  gives additional explanations about how the conversion is done. In the overwhelming majority of cases, applying any measure to a bipartite network, and to the same network made unipartite, should give the same results (connectance is one notable example).", 
            "title": "Data types"
        }, 
        {
            "location": "/types/#type-reference", 
            "text": "#  EcologicalNetwork.Bipartite     Type .  Bipartite type  All bipartite networks  source  #  EcologicalNetwork.BipartiteNetwork     Type .  BipartiteNetwork  A bipartite deterministic network.  source  #  EcologicalNetwork.BipartiteNetwork     Method .  Construct a bipartite network from a matrix of integer  source  #  EcologicalNetwork.EcoNetwork     Type .  EcoNetwork type  This is an abstract type that allows to generate functions for all sorts of networks. All other types are derived from this one.  source  #  EcologicalNetwork.Unipartite     Type .  Unipartite type  All unipartite networks  source  #  EcologicalNetwork.UnipartiteNetwork     Type .  UnipartiteNetwork  An unipartite deterministic network.  source  #  EcologicalNetwork.UnipartiteNetwork     Method .  Construct an unipartite network from a matrix of integer  source", 
            "title": "Type reference"
        }, 
        {
            "location": "/nullmodels/", 
            "text": "Null models\n\n\nEcologicalNetwork\n offers a number of ways to draw random binary networks from a template of probabilities. This is useful to generate networks under a null model, for example. All these functions will respect the fact that the network in bipartite or unipartite.\n\n\n\n\nCreating a deterministic network from a probabilistic network\n\n\nThere are a number of ways to generate a deterministic network from a probabilistic one. All of these functions take a network on a class belonging to \nProbabilisticNetwork\n, and return a network of a class belonging to \nDeterministicNetwork\n.\n\n\n\n\nConvert to deterministic\n\n\nThe first is simply to assing \ntrue\n to all interactions with a non-0 probability, and \nfalse\n to the others. This is done with the \nmake_binary\n function:\n\n\nN = UnipartiteProbaNetwork(eye(3))\nB = make_binary(N)\nB.A\n\n\n\n\n3\u00d73 Array{Bool,2}:\n  true  false  false\n false   true  false\n false  false   true\n\n\n\n\n#\n\n\nEcologicalNetwork.make_binary\n \n \nFunction\n.\n\n\nReturns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is greater than 0.\n\n\nsource\n\n\n\n\nUsing a threshold\n\n\nThe second way is to determine a cutoff for probabilities, below which they will be assigned \nfalse\n. This is done through \nmake_threshold\n:\n\n\nN = UnipartiteProbaNetwork(rand((4, 4)))\nB = make_threshold(N, 0.5)\nB.A\n\n\n\n\n4\u00d74 Array{Bool,2}:\n  true  false   true  false\n  true   true  false  false\n false   true   true  false\n  true   true  false   true\n\n\n\n\n#\n\n\nEcologicalNetwork.make_threshold\n \n \nFunction\n.\n\n\nReturns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is \n \nk\n. This is probably unwise to use this function since this practice is of questionnable relevance, but it is included for the sake of exhaustivity.\n\n\nk\n must be in [0;1[.\n\n\nsource\n\n\n\n\nRandom draws\n\n\nThe last way to convert a probabilistic network to a deterministic one is to perform one random draw for each interaction. In this scenario, \ntrue\n is assigned with a probability $P_{ij}$. This is done with the \nmake_bernoulli\n function:\n\n\nN = BipartiteProbaNetwork(rand((4, 4)))\nB = make_bernoulli(N)\nB.A\n\n\n\n\n4\u00d74 Array{Bool,2}:\n false   true  false  false\n false   true  false   true\n  true  false   true   true\n false  false  false  false\n\n\n\n\n#\n\n\nEcologicalNetwork.make_bernoulli\n \n \nFunction\n.\n\n\nReturns a matrix B of the same size as A, in which each element B(i,j) is 1 with probability A(i,j).\n\n\nsource\n\n\n\n\nCreating a probabilistic network from a deterministic network\n\n\nThe inverse operation can be done using the \nnullX\n functions. These functions use informations about the degree distribution to generate probabilistic networks:\n\n\n#\n\n\nEcologicalNetwork.null1\n \n \nFunction\n.\n\n\nGiven a matrix \nA\n, \nnull1(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the connectance of \nA\n.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null2\n \n \nFunction\n.\n\n\nGiven a matrix \nA\n, \nnull2(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the degree of each species.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null3in\n \n \nFunction\n.\n\n\nGiven a matrix \nA\n, \nnull3in(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the in-degree (number of predecessors) of each species, divided by the total number of possible predecessors.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null3out\n \n \nFunction\n.\n\n\nGiven a matrix \nA\n, \nnull3out(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the out-degree (number of successors) of each species, divided by the total number of possible successors.\n\n\nsource\n\n\nFor an example:\n\n\nN = make_bernoulli(BipartiteProbaNetwork(rand(3, 5)))\nnull2(N).A\n\n\n\n\n3\u00d75 Array{Float64,2}:\n 0.733333  0.733333  0.733333  0.733333  0.566667\n 0.533333  0.533333  0.533333  0.533333  0.366667\n 0.633333  0.633333  0.633333  0.633333  0.466667", 
            "title": "Null models"
        }, 
        {
            "location": "/nullmodels/#null-models", 
            "text": "EcologicalNetwork  offers a number of ways to draw random binary networks from a template of probabilities. This is useful to generate networks under a null model, for example. All these functions will respect the fact that the network in bipartite or unipartite.", 
            "title": "Null models"
        }, 
        {
            "location": "/nullmodels/#creating-a-deterministic-network-from-a-probabilistic-network", 
            "text": "There are a number of ways to generate a deterministic network from a probabilistic one. All of these functions take a network on a class belonging to  ProbabilisticNetwork , and return a network of a class belonging to  DeterministicNetwork .", 
            "title": "Creating a deterministic network from a probabilistic network"
        }, 
        {
            "location": "/nullmodels/#convert-to-deterministic", 
            "text": "The first is simply to assing  true  to all interactions with a non-0 probability, and  false  to the others. This is done with the  make_binary  function:  N = UnipartiteProbaNetwork(eye(3))\nB = make_binary(N)\nB.A  3\u00d73 Array{Bool,2}:\n  true  false  false\n false   true  false\n false  false   true  #  EcologicalNetwork.make_binary     Function .  Returns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is greater than 0.  source", 
            "title": "Convert to deterministic"
        }, 
        {
            "location": "/nullmodels/#using-a-threshold", 
            "text": "The second way is to determine a cutoff for probabilities, below which they will be assigned  false . This is done through  make_threshold :  N = UnipartiteProbaNetwork(rand((4, 4)))\nB = make_threshold(N, 0.5)\nB.A  4\u00d74 Array{Bool,2}:\n  true  false   true  false\n  true   true  false  false\n false   true   true  false\n  true   true  false   true  #  EcologicalNetwork.make_threshold     Function .  Returns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is    k . This is probably unwise to use this function since this practice is of questionnable relevance, but it is included for the sake of exhaustivity.  k  must be in [0;1[.  source", 
            "title": "Using a threshold"
        }, 
        {
            "location": "/nullmodels/#random-draws", 
            "text": "The last way to convert a probabilistic network to a deterministic one is to perform one random draw for each interaction. In this scenario,  true  is assigned with a probability $P_{ij}$. This is done with the  make_bernoulli  function:  N = BipartiteProbaNetwork(rand((4, 4)))\nB = make_bernoulli(N)\nB.A  4\u00d74 Array{Bool,2}:\n false   true  false  false\n false   true  false   true\n  true  false   true   true\n false  false  false  false  #  EcologicalNetwork.make_bernoulli     Function .  Returns a matrix B of the same size as A, in which each element B(i,j) is 1 with probability A(i,j).  source", 
            "title": "Random draws"
        }, 
        {
            "location": "/nullmodels/#creating-a-probabilistic-network-from-a-deterministic-network", 
            "text": "The inverse operation can be done using the  nullX  functions. These functions use informations about the degree distribution to generate probabilistic networks:  #  EcologicalNetwork.null1     Function .  Given a matrix  A ,  null1(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the connectance of  A .  source  #  EcologicalNetwork.null2     Function .  Given a matrix  A ,  null2(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the degree of each species.  source  #  EcologicalNetwork.null3in     Function .  Given a matrix  A ,  null3in(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the in-degree (number of predecessors) of each species, divided by the total number of possible predecessors.  source  #  EcologicalNetwork.null3out     Function .  Given a matrix  A ,  null3out(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the out-degree (number of successors) of each species, divided by the total number of possible successors.  source  For an example:  N = make_bernoulli(BipartiteProbaNetwork(rand(3, 5)))\nnull2(N).A  3\u00d75 Array{Float64,2}:\n 0.733333  0.733333  0.733333  0.733333  0.566667\n 0.533333  0.533333  0.533333  0.533333  0.366667\n 0.633333  0.633333  0.633333  0.633333  0.466667", 
            "title": "Creating a probabilistic network from a deterministic network"
        }
    ]
}