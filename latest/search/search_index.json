{
    "docs": [
        {
            "location": "/", 
            "text": "Analysis of ecological networks\n\n\nThe \nEcologicalNetwork\n package offers a convenient interface to analyze several types of ecological networks. Rather than providing multiple measures of the same property, we selected measures that have been demonstrated to work and be robust.\n\n\nYou can read more about the selection of measures in:\n\n\n\n\nDelmas, E. et al. Analyzing ecological networks of species interactions. bioRxiv 112540 (2017). doi:10.1101/112540\n\n\n\n\nThe structure of this documentation is trying to match (as much as possible) the structure of Delmas \net al.\n (\n2017\n), where most of the measures presented here are reviewed.\n\n\nThis package also offers an interface for probabilistic network, about which you can read more in:\n\n\n\n\nPoisot, T. et al. The structure of probabilistic networks. Methods in Ecology and Evolution 7, 303\u2013312 (2016). doi: 10.1111/2041-210X.12468", 
            "title": "Home"
        }, 
        {
            "location": "/#analysis-of-ecological-networks", 
            "text": "The  EcologicalNetwork  package offers a convenient interface to analyze several types of ecological networks. Rather than providing multiple measures of the same property, we selected measures that have been demonstrated to work and be robust.  You can read more about the selection of measures in:   Delmas, E. et al. Analyzing ecological networks of species interactions. bioRxiv 112540 (2017). doi:10.1101/112540   The structure of this documentation is trying to match (as much as possible) the structure of Delmas  et al.  ( 2017 ), where most of the measures presented here are reviewed.  This package also offers an interface for probabilistic network, about which you can read more in:   Poisot, T. et al. The structure of probabilistic networks. Methods in Ecology and Evolution 7, 303\u2013312 (2016). doi: 10.1111/2041-210X.12468", 
            "title": "Analysis of ecological networks"
        }, 
        {
            "location": "/types/", 
            "text": "Informations about types\n\n\nAs there are many ways to represent ecological networks, and the correct way to measure a given property varies in function of the representation, \nEcologicalNetwork\n has a series of built-in types.\n\n\n\n\nType hierarchy\n\n\nThe \nEcologicalNetwork\n package has six main types that are meant to be used by the user: \nBipartiteNetwork\n, \nBipartiteProbaNetwork\n, \nBipartiteQuantiNetwork\n, \nUnipartiteNetwork\n, \nUnipartiteProbaNetwork\n and \nUnipartiteQuantiNetwork\n. All types with \nProba\n in their names are meant to represent probabilistic networks, and are also part of the union type \nProbabilisticNetwork\n. All types \nwithout\n \nProba\n in their name are part of the union type \nDeterministicNetwork\n, and represent networks in which interactions are either present or absent. All types with \nQuanti\n in their names are part of the \nQuantitativeNetwork\n groups, and represent networks with weighted interactions. All types starting with \nBipartite\n are also part of the abstract type \nBipartite\n, and types with \nUnipartite\n in their names are part of the abstract type \nUnipartite\n. Finally, both \nUnipartite\n and \nBipartite\n are part of the abstract type \nEcoNetwork\n.\n\n\nAlthough this may seem convoluted, this is important to understand: when writing functions, you can restrict them to any type of network you want by using the right type in their declaration. You can also check properties of a network just by looking at its type. For example, one can check whether a network \nN\n is bipartite with:\n\n\ntypeof\n(\nN\n)\n \n:\n \nBipartite\n\n\n\n\n\n\nNetworks are represented as two-dimensional matrices. All types are simply wrappers around an adjacency matrix, stored as the \nA\n property of the object. To look at the adjacency matrix of a network \nN\n, one therefore uses \nN.A\n. These matrices must be read as: the existence/probability of an interaction \nfrom\n the species of the \ni\n-th row \nto\n the species in the \nj\n-th column. This implies that the networks are, by default, directed.\n\n\nNote that the type of a network will determine what methods can be applied to it. For example, all measures of variance are only making sense for probabilistic networks.\n\n\n\n\nData types\n\n\nInteractions in deterministic networks are represented as boolean (\ntrue\n/\nfalse\n) values. This is memory efficient, so large networks can be represented (one interactions represented as a boolean uses 8 times fewer memory than the same interaction represented as an integer). This being said, all networks of the \nDeterministicNetwork\n type can be read from matrices of integers, \nas long as these matrices only contain 0 and 1\n.\n\n\nIn probabilistic networks, interactions are stored as floating point (\nFloat64\n) numbers. These values have to be between 0.0 and 1.0, as they represent probabilities. In quantitative networks, interactions are stored as any type of number.\n\n\nNetworks of the \nUnipartite\n class must have the same number of rows and columns. The species in the rows and columns are the same. Networks of the \nBipartite\n class are expected to have different numbers of rows and columns, as the species in rows and columns are different species. It is possible to convert a network from \nBipartite\n to \nUnipartite\n using the \nmake_unipartite\n function:\n\n\nusing\n \nEcologicalNetwork\n\n\nB\n \n=\n \nBipartiteNetwork\n(\nrand\n(\nBool\n,\n \n(\n3\n,\n \n5\n)))\n\n\nU\n \n=\n \nmake_unipartite\n(\nB\n)\n\n\nrichness\n(\nU\n)\n \n==\n \nrichness\n(\nB\n)\n\n\n\n\n\n\ntrue\n\n\n\n\n\nThe documentation for \nmake_unipartite\n gives additional explanations about how the conversion is done. In the overwhelming majority of cases, applying any measure to a bipartite network, and to the same network made unipartite, should give the same results (connectance is one notable example).\n\n\n\n\nType reference\n\n\n#\n\n\nEcologicalNetwork.Bipartite\n \n \nType\n.\n\n\nAll bipartite networks\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.BipartiteNetwork\n \n \nType\n.\n\n\nA bipartite deterministic network is a two-dimensional array of boolean values.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.BipartiteNetwork\n \n \nMethod\n.\n\n\nConstruct a bipartite network from a matrix of integer\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.EcoNetwork\n \n \nType\n.\n\n\nThis is an abstract type that allows to generate functions for all sorts of networks. All other types are derived from this one.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.Unipartite\n \n \nType\n.\n\n\nAll unipartite networks\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.UnipartiteNetwork\n \n \nType\n.\n\n\nAn unipartite deterministic network.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.UnipartiteNetwork\n \n \nMethod\n.\n\n\nConstruct an unipartite network from a matrix of integer\n\n\nsource", 
            "title": "Different types of networks"
        }, 
        {
            "location": "/types/#informations-about-types", 
            "text": "As there are many ways to represent ecological networks, and the correct way to measure a given property varies in function of the representation,  EcologicalNetwork  has a series of built-in types.", 
            "title": "Informations about types"
        }, 
        {
            "location": "/types/#type-hierarchy", 
            "text": "The  EcologicalNetwork  package has six main types that are meant to be used by the user:  BipartiteNetwork ,  BipartiteProbaNetwork ,  BipartiteQuantiNetwork ,  UnipartiteNetwork ,  UnipartiteProbaNetwork  and  UnipartiteQuantiNetwork . All types with  Proba  in their names are meant to represent probabilistic networks, and are also part of the union type  ProbabilisticNetwork . All types  without   Proba  in their name are part of the union type  DeterministicNetwork , and represent networks in which interactions are either present or absent. All types with  Quanti  in their names are part of the  QuantitativeNetwork  groups, and represent networks with weighted interactions. All types starting with  Bipartite  are also part of the abstract type  Bipartite , and types with  Unipartite  in their names are part of the abstract type  Unipartite . Finally, both  Unipartite  and  Bipartite  are part of the abstract type  EcoNetwork .  Although this may seem convoluted, this is important to understand: when writing functions, you can restrict them to any type of network you want by using the right type in their declaration. You can also check properties of a network just by looking at its type. For example, one can check whether a network  N  is bipartite with:  typeof ( N )   :   Bipartite   Networks are represented as two-dimensional matrices. All types are simply wrappers around an adjacency matrix, stored as the  A  property of the object. To look at the adjacency matrix of a network  N , one therefore uses  N.A . These matrices must be read as: the existence/probability of an interaction  from  the species of the  i -th row  to  the species in the  j -th column. This implies that the networks are, by default, directed.  Note that the type of a network will determine what methods can be applied to it. For example, all measures of variance are only making sense for probabilistic networks.", 
            "title": "Type hierarchy"
        }, 
        {
            "location": "/types/#data-types", 
            "text": "Interactions in deterministic networks are represented as boolean ( true / false ) values. This is memory efficient, so large networks can be represented (one interactions represented as a boolean uses 8 times fewer memory than the same interaction represented as an integer). This being said, all networks of the  DeterministicNetwork  type can be read from matrices of integers,  as long as these matrices only contain 0 and 1 .  In probabilistic networks, interactions are stored as floating point ( Float64 ) numbers. These values have to be between 0.0 and 1.0, as they represent probabilities. In quantitative networks, interactions are stored as any type of number.  Networks of the  Unipartite  class must have the same number of rows and columns. The species in the rows and columns are the same. Networks of the  Bipartite  class are expected to have different numbers of rows and columns, as the species in rows and columns are different species. It is possible to convert a network from  Bipartite  to  Unipartite  using the  make_unipartite  function:  using   EcologicalNetwork  B   =   BipartiteNetwork ( rand ( Bool ,   ( 3 ,   5 )))  U   =   make_unipartite ( B )  richness ( U )   ==   richness ( B )   true  The documentation for  make_unipartite  gives additional explanations about how the conversion is done. In the overwhelming majority of cases, applying any measure to a bipartite network, and to the same network made unipartite, should give the same results (connectance is one notable example).", 
            "title": "Data types"
        }, 
        {
            "location": "/types/#type-reference", 
            "text": "#  EcologicalNetwork.Bipartite     Type .  All bipartite networks  source  #  EcologicalNetwork.BipartiteNetwork     Type .  A bipartite deterministic network is a two-dimensional array of boolean values.  source  #  EcologicalNetwork.BipartiteNetwork     Method .  Construct a bipartite network from a matrix of integer  source  #  EcologicalNetwork.EcoNetwork     Type .  This is an abstract type that allows to generate functions for all sorts of networks. All other types are derived from this one.  source  #  EcologicalNetwork.Unipartite     Type .  All unipartite networks  source  #  EcologicalNetwork.UnipartiteNetwork     Type .  An unipartite deterministic network.  source  #  EcologicalNetwork.UnipartiteNetwork     Method .  Construct an unipartite network from a matrix of integer  source", 
            "title": "Type reference"
        }, 
        {
            "location": "/data/", 
            "text": "Datasets\n\n\nEcologicalNetwork\n comes with a few datasets.\n\n\n\n\nUnipartite networks\n\n\n#\n\n\nEcologicalNetwork.stony\n \n \nFunction\n.\n\n\nStony food web\n\n\nstony()\n\n\n\n\n\nStony food web from Thompson \n Townsend. This was sampled in a tussock grassland near Otago, New Zealand. Note that there is, in the original matrix, a species with no interactions. It is removed when generating the network.\n\n\nsource\n\n\n\n\nBipartite networks\n\n\n#\n\n\nEcologicalNetwork.ollerton\n \n \nFunction\n.\n\n\nFish-anemone interactions\n\n\nFrom Ollerton et al. 2007\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.mcmullen\n \n \nFunction\n.\n\n\nPlant-flower visitor interactions in the Galapagos\n\n\nmcmullen()\n\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.robertson\n \n \nFunction\n.\n\n\nPollination interactions\n\n\nFrom Robertson 1927, in an agricultural area dominated by crops, with some natural forest and pasture.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.bluthgen\n \n \nFunction\n.\n\n\nNumber of visits from Bluthgen et al XXX\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.kato\n \n \nFunction\n.\n\n\nKyoto University Forest of Ashu pollination network\n\n\nkato()\n\n\n\n\n\nInteraction strength is the mumber of plant visits by insects.\n\n\nhttps://www.nceas.ucsb.edu/interactionweb/html/kato_1990.html\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.woods\n \n \nFunction\n.\n\n\nLake of the Woods host-parasite data\n\n\nInteractions content are prevalence.\n\n\nsource\n\n\n\n\nNetwork collections\n\n\n#\n\n\nEcologicalNetwork.soilphagebacteria\n \n \nFunction\n.\n\n\nSoil-isolated phage-bacteria networks\n\n\nsoilphagebacteria(i::Int64=1)\n\n\n\n\n\nInteractions are the impact of phage on the bacteria.\n\n\nhttps://figshare.com/articles/Phage_bacteria_networks_isolated_in_soil/696102\n\n\nTakes a positional argument \ni\n, indicating which network (from 1 to 5) to return.\n\n\n\n\nPoisot, T., Lounnas, M., Hochberg, M.E., 2013. The structure of natural microbial enemy-victim networks. Ecological Processes 2, 1. doi:10.1186/2192-1709-2-13\n\n\n\n\nsource", 
            "title": "Datasets"
        }, 
        {
            "location": "/data/#datasets", 
            "text": "EcologicalNetwork  comes with a few datasets.", 
            "title": "Datasets"
        }, 
        {
            "location": "/data/#unipartite-networks", 
            "text": "#  EcologicalNetwork.stony     Function .  Stony food web  stony()  Stony food web from Thompson   Townsend. This was sampled in a tussock grassland near Otago, New Zealand. Note that there is, in the original matrix, a species with no interactions. It is removed when generating the network.  source", 
            "title": "Unipartite networks"
        }, 
        {
            "location": "/data/#bipartite-networks", 
            "text": "#  EcologicalNetwork.ollerton     Function .  Fish-anemone interactions  From Ollerton et al. 2007  source  #  EcologicalNetwork.mcmullen     Function .  Plant-flower visitor interactions in the Galapagos  mcmullen()  source  #  EcologicalNetwork.robertson     Function .  Pollination interactions  From Robertson 1927, in an agricultural area dominated by crops, with some natural forest and pasture.  source  #  EcologicalNetwork.bluthgen     Function .  Number of visits from Bluthgen et al XXX  source  #  EcologicalNetwork.kato     Function .  Kyoto University Forest of Ashu pollination network  kato()  Interaction strength is the mumber of plant visits by insects.  https://www.nceas.ucsb.edu/interactionweb/html/kato_1990.html  source  #  EcologicalNetwork.woods     Function .  Lake of the Woods host-parasite data  Interactions content are prevalence.  source", 
            "title": "Bipartite networks"
        }, 
        {
            "location": "/data/#network-collections", 
            "text": "#  EcologicalNetwork.soilphagebacteria     Function .  Soil-isolated phage-bacteria networks  soilphagebacteria(i::Int64=1)  Interactions are the impact of phage on the bacteria.  https://figshare.com/articles/Phage_bacteria_networks_isolated_in_soil/696102  Takes a positional argument  i , indicating which network (from 1 to 5) to return.   Poisot, T., Lounnas, M., Hochberg, M.E., 2013. The structure of natural microbial enemy-victim networks. Ecological Processes 2, 1. doi:10.1186/2192-1709-2-13   source", 
            "title": "Network collections"
        }, 
        {
            "location": "/usecase/nestedness/", 
            "text": "Measuring the nestedness of a network\n\n\nThe goal of this use case is to (i) measure the nestedness of a bipartite network and (ii) evaluate whether it differs from the random expectation. We will use the \nollerton\n data, which are reasonably small, and the \n\u03b7\n measure of nestedness (note that \nnodf\n is also available).\n\n\nusing\n \nEcologicalNetwork\n\n\n\n# Get the data in an object\n\n\nN\n \n=\n \nollerton\n();\n\n\n\n# We will create a function to return the nestedness of the entire\n\n\n# network instead of an array of nestedness values\n\n\nnest\n \n=\n \n(\nx\n)\n \n-\n \n\u03b7\n(\nx\n)[\n1\n]\n\n\n\n# We will now generate a series of random networks preserving the degree\n\n\n# distribution\n\n\nS\n \n=\n \nnullmodel\n(\nnull2\n(\nN\n));\n\n\n\n# There is a function to apply a test rapidly to randomized networks. In this\n\n\n# situation we are interested in testing the fact that the network is more\n\n\n# nested than expected by chance.\n\n\nresults\n \n=\n \ntest_network_property\n(\nN\n,\n \nnest\n,\n \nS\n,\n \ntest\n=:\ngreater\n);\n\n\n\n# We can print the results\n\n\nprintln\n(\n\n        \nThe original network has a nestedness of \n,\n\n        \nround\n(\nnest\n(\nN\n),\n \n3\n),\n\n        \n,\n\\n\n,\n \nwhich is greater than expected by chance (p ~ \n,\n\n        \nround\n(\nresults\n.\npval\n,\n \n4\n),\n\n        \n) -- \n,\n\n        \nresults\n.\nn\n,\n\n        \n random networks.\n\n        \n)\n\n\n\n\n\n\nThe original network has a nestedness of 0.641,\nwhich is greater than expected by chance (p ~ 0.0) -- 285 random networks.\n\n\n\n\n\nIn this simple example, we used \nnullmodel\n to generate random realizations of a network, and \ntest_network_property\n to evaluate whether the observed nestedness was observed by chance. As it stands, all randomized networks had \nlower\n values, and so the \np\n-value is (essentially) null. In short, this network is significantly more nested than expected by chance knowing its degree distribution.", 
            "title": "Nestedness"
        }, 
        {
            "location": "/usecase/nestedness/#measuring-the-nestedness-of-a-network", 
            "text": "The goal of this use case is to (i) measure the nestedness of a bipartite network and (ii) evaluate whether it differs from the random expectation. We will use the  ollerton  data, which are reasonably small, and the  \u03b7  measure of nestedness (note that  nodf  is also available).  using   EcologicalNetwork  # Get the data in an object  N   =   ollerton ();  # We will create a function to return the nestedness of the entire  # network instead of an array of nestedness values  nest   =   ( x )   -   \u03b7 ( x )[ 1 ]  # We will now generate a series of random networks preserving the degree  # distribution  S   =   nullmodel ( null2 ( N ));  # There is a function to apply a test rapidly to randomized networks. In this  # situation we are interested in testing the fact that the network is more  # nested than expected by chance.  results   =   test_network_property ( N ,   nest ,   S ,   test =: greater );  # We can print the results  println ( \n         The original network has a nestedness of  , \n         round ( nest ( N ),   3 ), \n         , \\n ,   which is greater than expected by chance (p ~  , \n         round ( results . pval ,   4 ), \n         ) --  , \n         results . n , \n          random networks. \n         )   The original network has a nestedness of 0.641,\nwhich is greater than expected by chance (p ~ 0.0) -- 285 random networks.  In this simple example, we used  nullmodel  to generate random realizations of a network, and  test_network_property  to evaluate whether the observed nestedness was observed by chance. As it stands, all randomized networks had  lower  values, and so the  p -value is (essentially) null. In short, this network is significantly more nested than expected by chance knowing its degree distribution.", 
            "title": "Measuring the nestedness of a network"
        }, 
        {
            "location": "/usecase/modularity/", 
            "text": "Measuring the modularity\n\n\nIn this example, we will use \nlabel_propagation\n to optimize the modularity of a network. The data are from the \nmcmullen\n dataset.\n\n\nusing\n \nEcologicalNetwork\n\n\n\n# Get the data in an object\n\n\nN\n \n=\n \nmcmullen\n();\n\n\n\n\n\n\nEcologicalNetwork.BipartiteNetwork(Bool[false false \u2026 false false; false false \u2026 false false; \u2026 ; true false \u2026 false false; true true \u2026 true true])\n\n\n\n\n\nThe next step is to generate starting communities for every species. We will assign species to random initial modules:\n\n\nL\n \n=\n \nrand\n(\n1\n:\nrichness\n(\nN\n),\n \nrichness\n(\nN\n));\n\n\n\n\n\n\n159-element Array{Int64,1}:\n  94\n 117\n  13\n  38\n  82\n 114\n  18\n  30\n  15\n 159\n   \u22ee\n  30\n  30\n  58\n 127\n  41\n  37\n 118\n  53\n 127\n\n\n\n\n\nWe can now start a repeated number of attempts to find the best partition, here using \nbrim\n. If \njulia\n is started in parallel, this will use all assigned CPUs.\n\n\nM\n \n=\n \nmodularity\n(\nN\n,\n \nL\n,\n \nbrim\n,\n \nreplicates\n=\n100\n);\n\n\n\n# Finally, we can get the best partition\n\n\nb_part\n \n=\n \nbest_partition\n(\nM\n);\n\n\n\n# And print its modularity and number of modules\n\n\nprintln\n(\nQ: \n,\n\n        \nround\n(\nb_part\n[\n1\n]\n.\nQ\n,\n \n2\n),\n\n        \n |c|: \n,\n\n        \nlength\n(\nunique\n(\nb_part\n[\n1\n]\n.\nL\n))\n\n        \n)\n\n\n\n\n\n\nQ\n:\n \n0.51\n \n|\nc\n|:\n \n28", 
            "title": "Modularity"
        }, 
        {
            "location": "/usecase/modularity/#measuring-the-modularity", 
            "text": "In this example, we will use  label_propagation  to optimize the modularity of a network. The data are from the  mcmullen  dataset.  using   EcologicalNetwork  # Get the data in an object  N   =   mcmullen ();   EcologicalNetwork.BipartiteNetwork(Bool[false false \u2026 false false; false false \u2026 false false; \u2026 ; true false \u2026 false false; true true \u2026 true true])  The next step is to generate starting communities for every species. We will assign species to random initial modules:  L   =   rand ( 1 : richness ( N ),   richness ( N ));   159-element Array{Int64,1}:\n  94\n 117\n  13\n  38\n  82\n 114\n  18\n  30\n  15\n 159\n   \u22ee\n  30\n  30\n  58\n 127\n  41\n  37\n 118\n  53\n 127  We can now start a repeated number of attempts to find the best partition, here using  brim . If  julia  is started in parallel, this will use all assigned CPUs.  M   =   modularity ( N ,   L ,   brim ,   replicates = 100 );  # Finally, we can get the best partition  b_part   =   best_partition ( M );  # And print its modularity and number of modules  println ( Q:  , \n         round ( b_part [ 1 ] . Q ,   2 ), \n          |c|:  , \n         length ( unique ( b_part [ 1 ] . L )) \n         )   Q :   0.51   | c |:   28", 
            "title": "Measuring the modularity"
        }, 
        {
            "location": "/usecase/motifs/", 
            "text": "Counting motifs\n\n\nIn this use case, we will count the number of motifs in a food web. Specifically, we will count how many times there is a linear food chain (A\u2192B\u2192C) between three species.\n\n\nusing\n \nEcologicalNetwork\n\n\n\n# Load a network\n\n\nN\n \n=\n \nstony\n();\n\n\n\n# List of motifs\n\n\nm\n \n=\n \nunipartitemotifs\n();\n\n\n\n\n\n\nDict{Symbol,EcologicalNetwork.UnipartiteNetwork} with 13 entries:\n  :D4 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :S1 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :D1 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026\n  :D6 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true true; true false t\u2026\n  :D3 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false false true; false false\u2026\n  :D5 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :S4 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :S3 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :D8 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true true; true false f\u2026\n  :S2 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026\n  :D2 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026\n  :D7 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true true; true false f\u2026\n  :S5 =\n EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026\n\n\n\n\n\nThe \nm\n object has 13 different motifs, named as in \nStouffer \net al.\n (2007)\n. The function \nunipartitemotifs\n will generate them when needed.\n\n\nThe function to count motifs is called \nmotif\n, and returns a count: how many triplets of species are in a given conformation. For example:\n\n\ns1\n \n=\n \nmotif\n(\nN\n,\n \nm\n[\n:\nS1\n])\n\n\n\n\n\n\n1035.0\n\n\n\n\n\nWe may be interested in knowing whether this motif is over or under-represented in the empirical network, compared to a random expectation. To determine this, we will shuffle interactions around in a way that preserves the number of interactions\nand\n the degree distribution of all species, using \nswaps\n. We will create 100 replicated networks to test.\n\n\npermutations\n \n=\n \nswaps\n(\nN\n,\n \n100\n,\n \nconstraint\n=:\ndegree\n)\n\n\n\nms1\n \n=\n \nmap\n(\nx\n \n-\n \nmotif\n(\nx\n,\n \nm\n[\n:\nS1\n]),\n \npermutations\n)\n\n\n\n\n\n\n100-element Array{Float64,1}:\n 528.0\n 538.0\n 557.0\n 607.0\n 571.0\n 498.0\n 572.0\n 571.0\n 650.0\n 662.0\n   \u22ee\n 584.0\n 627.0\n 635.0\n 550.0\n 505.0\n 636.0\n 677.0\n 544.0\n 560.0", 
            "title": "Motifs"
        }, 
        {
            "location": "/usecase/motifs/#counting-motifs", 
            "text": "In this use case, we will count the number of motifs in a food web. Specifically, we will count how many times there is a linear food chain (A\u2192B\u2192C) between three species.  using   EcologicalNetwork  # Load a network  N   =   stony ();  # List of motifs  m   =   unipartitemotifs ();   Dict{Symbol,EcologicalNetwork.UnipartiteNetwork} with 13 entries:\n  :D4 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :S1 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :D1 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026\n  :D6 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true true; true false t\u2026\n  :D3 =  EcologicalNetwork.UnipartiteNetwork(Bool[false false true; false false\u2026\n  :D5 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :S4 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :S3 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true false; false false\u2026\n  :D8 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true true; true false f\u2026\n  :S2 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026\n  :D2 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026\n  :D7 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true true; true false f\u2026\n  :S5 =  EcologicalNetwork.UnipartiteNetwork(Bool[false true true; false false \u2026  The  m  object has 13 different motifs, named as in  Stouffer  et al.  (2007) . The function  unipartitemotifs  will generate them when needed.  The function to count motifs is called  motif , and returns a count: how many triplets of species are in a given conformation. For example:  s1   =   motif ( N ,   m [ : S1 ])   1035.0  We may be interested in knowing whether this motif is over or under-represented in the empirical network, compared to a random expectation. To determine this, we will shuffle interactions around in a way that preserves the number of interactions and  the degree distribution of all species, using  swaps . We will create 100 replicated networks to test.  permutations   =   swaps ( N ,   100 ,   constraint =: degree )  ms1   =   map ( x   -   motif ( x ,   m [ : S1 ]),   permutations )   100-element Array{Float64,1}:\n 528.0\n 538.0\n 557.0\n 607.0\n 571.0\n 498.0\n 572.0\n 571.0\n 650.0\n 662.0\n   \u22ee\n 584.0\n 627.0\n 635.0\n 550.0\n 505.0\n 636.0\n 677.0\n 544.0\n 560.0", 
            "title": "Counting motifs"
        }, 
        {
            "location": "/usecase/plot/", 
            "text": "Plotting\n\n\nCurrently, plotting is only implemented for \nBipartite\n networks (and only partially so). Plotting uses the \nPlots.jl\n package, so you can simply use:\n\n\nplot\n(\nN\n)\n\n\n\n\n\n\nwhere \nN\n is a network object. By default, species are sorted by degree. If you want species to be sorted by module, you need to pass a \nPartition\n object too:\n\n\nplot\n(\nN\n,\n \nP\n)", 
            "title": "Plots"
        }, 
        {
            "location": "/usecase/plot/#plotting", 
            "text": "Currently, plotting is only implemented for  Bipartite  networks (and only partially so). Plotting uses the  Plots.jl  package, so you can simply use:  plot ( N )   where  N  is a network object. By default, species are sorted by degree. If you want species to be sorted by module, you need to pass a  Partition  object too:  plot ( N ,   P )", 
            "title": "Plotting"
        }, 
        {
            "location": "/community/nlinks/", 
            "text": "Number of links and connectance\n\n\n\n\nNumber of links\n\n\n#\n\n\nEcologicalNetwork.links\n \n \nFunction\n.\n\n\nNumber of links in a network\n\n\nlinks(N::EcoNetwork)\n\n\n\n\n\nFor all type of networks, this is the sum of the adjacency matrix. Note that for quantitative networks, this is the cumulative sum of link weights.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.link_number\n \n \nFunction\n.\n\n\nNumber of links in a quantitative network\n\n\nlink_number(N::QuantitativeNetwork)\n\n\n\n\n\nIn quantitative networks only, returns the number of non-zero interactions.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.links_var\n \n \nFunction\n.\n\n\nVariance in the expected number of links\n\n\nlinks_var(N::ProbabilisticNetwork)\n\n\n\n\n\nExpected variance of the number of links for a probabilistic network.\n\n\nsource\n\n\n\n\nLinkage density\n\n\n#\n\n\nEcologicalNetwork.linkage_density\n \n \nFunction\n.\n\n\nLinkage density\n\n\nlinkage_density(N::DeterministicNetwork)\n\n\n\n\n\nNumber of links divided by species richness.\n\n\nsource\n\n\n\n\nConnectance\n\n\n#\n\n\nEcologicalNetwork.connectance\n \n \nFunction\n.\n\n\nConnectance\n\n\nconnectance(N::EcoNetwork)\n\n\n\n\n\nNumber of links divided by the number of possible interactions. In unipartite networks, this is $L/S^2$. In bipartite networks, this is $L/(T \u00d7 B)$.\n\n\nsource\n\n\nConnectance of a quantitative network\n\n\nconnectance(N::QuantitativeNetwork)\n\n\n\n\n\nConnectance of a quantitative network \u2013 the information on link weight is ignored.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.connectance_var\n \n \nFunction\n.\n\n\nVariance in the expected connectance\n\n\nconnectance_var(N::ProbabilisticNetwork)\n\n\n\n\n\nExpected variance of the connectance for a probabilistic matrix, measured as the variance of the number of links divided by the squared size of the matrix.\n\n\nsource", 
            "title": "Linkage density and connectance"
        }, 
        {
            "location": "/community/nlinks/#number-of-links-and-connectance", 
            "text": "", 
            "title": "Number of links and connectance"
        }, 
        {
            "location": "/community/nlinks/#number-of-links", 
            "text": "#  EcologicalNetwork.links     Function .  Number of links in a network  links(N::EcoNetwork)  For all type of networks, this is the sum of the adjacency matrix. Note that for quantitative networks, this is the cumulative sum of link weights.  source  #  EcologicalNetwork.link_number     Function .  Number of links in a quantitative network  link_number(N::QuantitativeNetwork)  In quantitative networks only, returns the number of non-zero interactions.  source  #  EcologicalNetwork.links_var     Function .  Variance in the expected number of links  links_var(N::ProbabilisticNetwork)  Expected variance of the number of links for a probabilistic network.  source", 
            "title": "Number of links"
        }, 
        {
            "location": "/community/nlinks/#linkage-density", 
            "text": "#  EcologicalNetwork.linkage_density     Function .  Linkage density  linkage_density(N::DeterministicNetwork)  Number of links divided by species richness.  source", 
            "title": "Linkage density"
        }, 
        {
            "location": "/community/nlinks/#connectance", 
            "text": "#  EcologicalNetwork.connectance     Function .  Connectance  connectance(N::EcoNetwork)  Number of links divided by the number of possible interactions. In unipartite networks, this is $L/S^2$. In bipartite networks, this is $L/(T \u00d7 B)$.  source  Connectance of a quantitative network  connectance(N::QuantitativeNetwork)  Connectance of a quantitative network \u2013 the information on link weight is ignored.  source  #  EcologicalNetwork.connectance_var     Function .  Variance in the expected connectance  connectance_var(N::ProbabilisticNetwork)  Expected variance of the connectance for a probabilistic matrix, measured as the variance of the number of links divided by the squared size of the matrix.  source", 
            "title": "Connectance"
        }, 
        {
            "location": "/community/degree/", 
            "text": "Degree distribution\n\n\n\n\nSpecies richness\n\n\n#\n\n\nEcologicalNetwork.richness\n \n \nFunction\n.\n\n\nRichness (number of species) in a bipartite network\n\n\nsource\n\n\nRichness (number of species) in a unipartite network\n\n\nsource\n\n\n\n\nCounting degrees\n\n\n#\n\n\nEcologicalNetwork.degree\n \n \nFunction\n.\n\n\nDegree of species in a unipartite network\n\n\ndegree(N::Unipartite)\n\n\n\n\n\nsource\n\n\nDegree of species in a bipartite network\n\n\ndegree(N::Bipartite)\n\n\n\n\n\nThis is a concatenation of the out degree and the in degrees of nodes on both sizes, as measured by making the graph unipartite first. Rows are first, columns second.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.degree_out\n \n \nFunction\n.\n\n\nExpected number of outgoing degrees\n\n\ndegree_out(N::EcoNetwork)\n\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.degree_in\n \n \nFunction\n.\n\n\nExpected number of ingoing degrees\n\n\ndegree_in(N::EcoNetwork)\n\n\n\n\n\nsource\n\n\nFor probabilistic networks only, there are measures of degree variance:\n\n\n#\n\n\nEcologicalNetwork.degree_var\n \n \nFunction\n.\n\n\nVariance in the degree\n\n\ndegree_var(N::UnipartiteProbaNetwork)\n\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.degree_out_var\n \n \nFunction\n.\n\n\nVariance in the outgoing degree\n\n\ndegree_out_var(N::ProbabilisticNetwork)\n\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.degree_in_var\n \n \nFunction\n.\n\n\nVariance in the ingoing degree\n\n\ndegree_in_var(N::ProbabilisticNetwork)\n\n\n\n\n\nsource", 
            "title": "Degree distribution"
        }, 
        {
            "location": "/community/degree/#degree-distribution", 
            "text": "", 
            "title": "Degree distribution"
        }, 
        {
            "location": "/community/degree/#species-richness", 
            "text": "#  EcologicalNetwork.richness     Function .  Richness (number of species) in a bipartite network  source  Richness (number of species) in a unipartite network  source", 
            "title": "Species richness"
        }, 
        {
            "location": "/community/degree/#counting-degrees", 
            "text": "#  EcologicalNetwork.degree     Function .  Degree of species in a unipartite network  degree(N::Unipartite)  source  Degree of species in a bipartite network  degree(N::Bipartite)  This is a concatenation of the out degree and the in degrees of nodes on both sizes, as measured by making the graph unipartite first. Rows are first, columns second.  source  #  EcologicalNetwork.degree_out     Function .  Expected number of outgoing degrees  degree_out(N::EcoNetwork)  source  #  EcologicalNetwork.degree_in     Function .  Expected number of ingoing degrees  degree_in(N::EcoNetwork)  source  For probabilistic networks only, there are measures of degree variance:  #  EcologicalNetwork.degree_var     Function .  Variance in the degree  degree_var(N::UnipartiteProbaNetwork)  source  #  EcologicalNetwork.degree_out_var     Function .  Variance in the outgoing degree  degree_out_var(N::ProbabilisticNetwork)  source  #  EcologicalNetwork.degree_in_var     Function .  Variance in the ingoing degree  degree_in_var(N::ProbabilisticNetwork)  source", 
            "title": "Counting degrees"
        }, 
        {
            "location": "/community/motifs/", 
            "text": "Counting motifs\n\n\n\n\nWarning\n\n\nThe enumeration of motifs can take a little while. It depends on the number of nodes in the networks, and in the number of nodes in the motif. It may be wise, in case you want to count several motifs on a single network, to use Julia's parallel computing abilities to speed things up.\n\n\n\n\n\n\nHow it works\n\n\nInternally, the code to count motifs is \nNot Elegant\n\u2122. Every motif is represented by its adjacency matrix, as a \nDeterministicNetwork\n object. Then \nall\n possible induced sub-graphs with the same number of nodes (at either level if this is a \nBipartite\n) are extracted, and matched against all \nunique\n possible permutations of the motif. If there is a match, then this induced subgraph is an instance of this motif.\n\n\n#\n\n\nEcologicalNetwork.motif\n \n \nFunction\n.\n\n\nCount motifs\n\n\nmotif(N::EcoNetwork, m::DeterministicNetwork)\n\n\n\n\n\nIn a network \nN\n, counts the number of time a motif \nm\n appears. In the case of a probabilistic network, \nN\n is the expected number of motifs. In the case of a quantitative network, \nN\n is the number of times the motif appears in the unweighted network.\n\n\nNote that because self-edges (\na.k.a.\n loops, or cannibalism) are \nnot\n counted in the motifs (the adjacency matrix is treated as if it had all diagonal elements set to 0).\n\n\nsource\n\n\n\n\nCaveats\n\n\nThe motifs are counted in a way that ignore self-links. This should not be an issue most of the time, and was also the ways this was done in most publications counting motifs in ecological networks.\n\n\n\n\nUsual motifs\n\n\n#\n\n\nEcologicalNetwork.unipartitemotifs\n \n \nFunction\n.\n\n\nUnipartite motifs\n\n\nunipartitemotifs()\n\n\n\n\n\nThe names of the motifs come from Stouffer et al. (2007) \u2013 especially Fig. 1, available online at \nhttp://rspb.royalsocietypublishing.org/content/274/1621/1931.figures-only\n\n\nsource", 
            "title": "Interaction motifs"
        }, 
        {
            "location": "/community/motifs/#counting-motifs", 
            "text": "Warning  The enumeration of motifs can take a little while. It depends on the number of nodes in the networks, and in the number of nodes in the motif. It may be wise, in case you want to count several motifs on a single network, to use Julia's parallel computing abilities to speed things up.", 
            "title": "Counting motifs"
        }, 
        {
            "location": "/community/motifs/#how-it-works", 
            "text": "Internally, the code to count motifs is  Not Elegant \u2122. Every motif is represented by its adjacency matrix, as a  DeterministicNetwork  object. Then  all  possible induced sub-graphs with the same number of nodes (at either level if this is a  Bipartite ) are extracted, and matched against all  unique  possible permutations of the motif. If there is a match, then this induced subgraph is an instance of this motif.  #  EcologicalNetwork.motif     Function .  Count motifs  motif(N::EcoNetwork, m::DeterministicNetwork)  In a network  N , counts the number of time a motif  m  appears. In the case of a probabilistic network,  N  is the expected number of motifs. In the case of a quantitative network,  N  is the number of times the motif appears in the unweighted network.  Note that because self-edges ( a.k.a.  loops, or cannibalism) are  not  counted in the motifs (the adjacency matrix is treated as if it had all diagonal elements set to 0).  source", 
            "title": "How it works"
        }, 
        {
            "location": "/community/motifs/#caveats", 
            "text": "The motifs are counted in a way that ignore self-links. This should not be an issue most of the time, and was also the ways this was done in most publications counting motifs in ecological networks.", 
            "title": "Caveats"
        }, 
        {
            "location": "/community/motifs/#usual-motifs", 
            "text": "#  EcologicalNetwork.unipartitemotifs     Function .  Unipartite motifs  unipartitemotifs()  The names of the motifs come from Stouffer et al. (2007) \u2013 especially Fig. 1, available online at  http://rspb.royalsocietypublishing.org/content/274/1621/1931.figures-only  source", 
            "title": "Usual motifs"
        }, 
        {
            "location": "/community/nestedness/", 
            "text": "Nestedness\n\n\nThe recommended measure of nestedness (working both for deterministic and probabilistic networks) is \u03b7:\n\n\n#\n\n\nEcologicalNetwork.\u03b7\n \n \nFunction\n.\n\n\nNestedness \u03b7 of a matrix\n\n\n\u03b7(N::Union{BipartiteNetwork, BipartiteProbaNetwork})\n\n\n\n\n\nThis returns the nestedness of the entire matrix, of the columns, and of the rows.\n\n\nsource\n\n\nWe also implement NODF, for deterministic networks, and its quantitative variant WNODF:\n\n\n#\n\n\nEcologicalNetwork.nodf\n \n \nFunction\n.\n\n\nNestedness based on Overlap and Decreasing Fill\n\n\nnodf(N::Union{BipartiteNetwork,BipartiteQuantiNetwork})\n\n\n\n\n\nIf the network is quantitative, then \nWNODF\n is measured instead of \nNODF\n. Note that in \nall\n situations, the value goes between 0 (not nested) to 1 (perfectly nested). This is a change with regard to the original papers, in which the maximal value is 100. The values returned are the nestedness of the network, of the columns, and of the rows.\n\n\nsource", 
            "title": "Nestedness"
        }, 
        {
            "location": "/community/nestedness/#nestedness", 
            "text": "The recommended measure of nestedness (working both for deterministic and probabilistic networks) is \u03b7:  #  EcologicalNetwork.\u03b7     Function .  Nestedness \u03b7 of a matrix  \u03b7(N::Union{BipartiteNetwork, BipartiteProbaNetwork})  This returns the nestedness of the entire matrix, of the columns, and of the rows.  source  We also implement NODF, for deterministic networks, and its quantitative variant WNODF:  #  EcologicalNetwork.nodf     Function .  Nestedness based on Overlap and Decreasing Fill  nodf(N::Union{BipartiteNetwork,BipartiteQuantiNetwork})  If the network is quantitative, then  WNODF  is measured instead of  NODF . Note that in  all  situations, the value goes between 0 (not nested) to 1 (perfectly nested). This is a change with regard to the original papers, in which the maximal value is 100. The values returned are the nestedness of the network, of the columns, and of the rows.  source", 
            "title": "Nestedness"
        }, 
        {
            "location": "/community/modularity/", 
            "text": "Modularity\n\n\nThere are a number of modularity-related functions in \nEcologicalNetworks\n. The optimal modularity structure is detected by optimizing $Q$, which returns values increasingly close to unity when the modular structure is strong. The $Q_r$ measure is also included for \na posteriori\n evaluation of the modularity.\n\n\n\n\nTypes\n\n\nThe object returned by all modularity detection functions has the type \nPartition\n.\n\n\n#\n\n\nEcologicalNetwork.Partition\n \n \nType\n.\n\n\nCommunity partition\n\n\nThis type has three elements:\n\n\n\n\nN\n, the network\n\n\nL\n, the array of (integers) module labels\n\n\nQ\n, if needed, the modularity value\n\n\n\n\nsource\n\n\n\n\nMeasures of modularity\n\n\n#\n\n\nEcologicalNetwork.Q\n \n \nFunction\n.\n\n\nModularity\n\n\nQ(N::EcoNetwork, L::Array{Int64, 1})\n\n\n\n\n\nThis measures modularity based on a matrix and a list of module labels. Note that this function assumes that interactions are directional, so that $A_{ij}$ represents an interaction from $i$ to $j$, but not the other way around.\n\n\nsource\n\n\nModularity (from a \nPartition\n)\n\n\nQ(P::Partition)\n\n\n\n\n\nThis measures Barber's bipartite modularity based on a \nPartition\n object, and update the object in the proccess.\n\n\nsource\n\n\nIn addition, there is a measure of \nrealized\n modularity:\n\n\n#\n\n\nEcologicalNetwork.Qr\n \n \nFunction\n.\n\n\nRealized modularity\n\n\nQr(N::EcoNetwork, L::Array{Int64, 1})\n\n\n\n\n\nMeasures realized modularity, based on a  a matrix and a list of module labels. Realized modularity usually takes values in the [0;1] interval, and is the proportion of interactions established \nwithin\n modules.\n\n\nThe realized modularity is defined as $Q_R' = 2 imes (W/E) - 1$, where $W$ is the number of links \nwithin\n modules, and $E$ is the total number of links.\n\n\nNote that in some situations, \nQr\n can be \nlower\n than 0. This reflects a partition in which more links are established between than within modules.\n\n\nsource\n\n\nRealized modularity (from a \nPartition\n)\n\n\nQr(P::Partition)\n\n\n\n\n\nMeasures realized modularity, based on a \nPartition\n object.\n\n\nsource\n\n\n\n\nFunctions for modularity detection\n\n\nThe first function included is \nlabel_propagation\n, which is working well for large graphs. It can also be useful to generate an initial modular partition.\n\n\n#\n\n\nEcologicalNetwork.label_propagation\n \n \nFunction\n.\n\n\nLabel propagation\n\n\nlabel_propagation(N::EcoNetwork, L::Array{Int64, 1})\n\n\n\n\n\nsource\n\n\nFor larger graphs (as long as they are not probabilistic), there is the \nlouvain\n function. It is \nnot\n the most aggressively optimized implementation.\n\n\n#\n\n\nEcologicalNetwork.louvain\n \n \nFunction\n.\n\n\nLouvain method for modularity on large networks\n\n\nlouvain(N::NonProbabilisticNetwork, L::Array{Int64, 1})\n\n\n\n\n\nTODO\n\n\nsource\n\n\nFinally, there is a \nbrim\n function for bipartite networks.\n\n\n#\n\n\nEcologicalNetwork.brim\n \n \nFunction\n.\n\n\nBipartite Recursively Induced Modularity\n\n\nbrim(P::Partition)\n\n\n\n\n\nReturns the best partition using BRIM, based on a Partition object.\n\n\nsource\n\n\nBipartite Recursively Induced Modularity\n\n\nbrim(N::BipartiteNetwork, L::Array{Int64, 1})\n\n\n\n\n\nReturns the best partition using BRIM, based on a network and an initial set of modules.\n\n\nsource\n\n\n\n\nAnalyze modularity\n\n\n#\n\n\nEcologicalNetwork.modularity\n \n \nFunction\n.\n\n\nDetect modules in a network\n\n\nmodularity\n(\nN\n::\nEcoNetwork\n,\n \nL\n::\nArray\n{\nInt64,\n \n1\n}\n,\n \nf\n::\nFunction\n;\n \nreplicates\n::\nInt64\n=\n100\n)\n\n\n\n\n\n\nThis function is a wrapper for the modularity code. The number of replicates is the number of times the modularity optimization should be run.\n\n\nArguments:\n\n\n\n\nN::EcoNetwork\n, the network to work on\n\n\nL::Array{Int64,1}\n, an array of module identities\n\n\nf::Function\n, the function to use\n\n\n\n\nThe function \nf\n \nmust\n (1) accept \nN, L\n as arguments, and (2) return a \nPartition\n as an output. Note that by default, \nL\n will be set to \nnothing\n, and modules will be generated at random. In unipartite networks, there can be up to one module per species. In bipartite networks, the minimum number of modules is the richness of the less speciose level.\n\n\nKeywords:\n\n\n\n\nreplicates::Int64\n, defaults to \n100\n\n\n\n\nsource\n\n\n\n\nSelect the best partition\n\n\n#\n\n\nEcologicalNetwork.best_partition\n \n \nFunction\n.\n\n\nMost modular partition\n\n\nbest_partition(modpart; f::Function=Q)\n\n\n\n\n\nReturn the best partition out of a number of replicates. This returns an \narray\n of partitions. If there is a single partition maximizing the given function \nf\n (as a keyword), the results are \nstill\n returned as an array with a single element.\n\n\nArguments:\n\n\n\n\nmodpart::Array{Partition,1}\n, an array of partitions returned by \ne.g.\n \nmodularity\n\n\n\n\nKeywords:\n\n\n\n\nf::Function\n, either \nQ\n or \nQr\n (any function for which the highest value  represents a more modular structure).\n\n\n\n\nsource\n\n\n\n\nNetwork roles\n\n\n#\n\n\nEcologicalNetwork.networkroles\n \n \nFunction\n.\n\n\nNetwork roles based on modularity\n\n\nnetworkroles\n(\nP\n::\nPartition\n)\n\n\n\n\n\n\nsource", 
            "title": "Modularity"
        }, 
        {
            "location": "/community/modularity/#modularity", 
            "text": "There are a number of modularity-related functions in  EcologicalNetworks . The optimal modularity structure is detected by optimizing $Q$, which returns values increasingly close to unity when the modular structure is strong. The $Q_r$ measure is also included for  a posteriori  evaluation of the modularity.", 
            "title": "Modularity"
        }, 
        {
            "location": "/community/modularity/#types", 
            "text": "The object returned by all modularity detection functions has the type  Partition .  #  EcologicalNetwork.Partition     Type .  Community partition  This type has three elements:   N , the network  L , the array of (integers) module labels  Q , if needed, the modularity value   source", 
            "title": "Types"
        }, 
        {
            "location": "/community/modularity/#measures-of-modularity", 
            "text": "#  EcologicalNetwork.Q     Function .  Modularity  Q(N::EcoNetwork, L::Array{Int64, 1})  This measures modularity based on a matrix and a list of module labels. Note that this function assumes that interactions are directional, so that $A_{ij}$ represents an interaction from $i$ to $j$, but not the other way around.  source  Modularity (from a  Partition )  Q(P::Partition)  This measures Barber's bipartite modularity based on a  Partition  object, and update the object in the proccess.  source  In addition, there is a measure of  realized  modularity:  #  EcologicalNetwork.Qr     Function .  Realized modularity  Qr(N::EcoNetwork, L::Array{Int64, 1})  Measures realized modularity, based on a  a matrix and a list of module labels. Realized modularity usually takes values in the [0;1] interval, and is the proportion of interactions established  within  modules.  The realized modularity is defined as $Q_R' = 2 imes (W/E) - 1$, where $W$ is the number of links  within  modules, and $E$ is the total number of links.  Note that in some situations,  Qr  can be  lower  than 0. This reflects a partition in which more links are established between than within modules.  source  Realized modularity (from a  Partition )  Qr(P::Partition)  Measures realized modularity, based on a  Partition  object.  source", 
            "title": "Measures of modularity"
        }, 
        {
            "location": "/community/modularity/#functions-for-modularity-detection", 
            "text": "The first function included is  label_propagation , which is working well for large graphs. It can also be useful to generate an initial modular partition.  #  EcologicalNetwork.label_propagation     Function .  Label propagation  label_propagation(N::EcoNetwork, L::Array{Int64, 1})  source  For larger graphs (as long as they are not probabilistic), there is the  louvain  function. It is  not  the most aggressively optimized implementation.  #  EcologicalNetwork.louvain     Function .  Louvain method for modularity on large networks  louvain(N::NonProbabilisticNetwork, L::Array{Int64, 1})  TODO  source  Finally, there is a  brim  function for bipartite networks.  #  EcologicalNetwork.brim     Function .  Bipartite Recursively Induced Modularity  brim(P::Partition)  Returns the best partition using BRIM, based on a Partition object.  source  Bipartite Recursively Induced Modularity  brim(N::BipartiteNetwork, L::Array{Int64, 1})  Returns the best partition using BRIM, based on a network and an initial set of modules.  source", 
            "title": "Functions for modularity detection"
        }, 
        {
            "location": "/community/modularity/#analyze-modularity", 
            "text": "#  EcologicalNetwork.modularity     Function .  Detect modules in a network  modularity ( N :: EcoNetwork ,   L :: Array { Int64,   1 } ,   f :: Function ;   replicates :: Int64 = 100 )   This function is a wrapper for the modularity code. The number of replicates is the number of times the modularity optimization should be run.  Arguments:   N::EcoNetwork , the network to work on  L::Array{Int64,1} , an array of module identities  f::Function , the function to use   The function  f   must  (1) accept  N, L  as arguments, and (2) return a  Partition  as an output. Note that by default,  L  will be set to  nothing , and modules will be generated at random. In unipartite networks, there can be up to one module per species. In bipartite networks, the minimum number of modules is the richness of the less speciose level.  Keywords:   replicates::Int64 , defaults to  100   source", 
            "title": "Analyze modularity"
        }, 
        {
            "location": "/community/modularity/#select-the-best-partition", 
            "text": "#  EcologicalNetwork.best_partition     Function .  Most modular partition  best_partition(modpart; f::Function=Q)  Return the best partition out of a number of replicates. This returns an  array  of partitions. If there is a single partition maximizing the given function  f  (as a keyword), the results are  still  returned as an array with a single element.  Arguments:   modpart::Array{Partition,1} , an array of partitions returned by  e.g.   modularity   Keywords:   f::Function , either  Q  or  Qr  (any function for which the highest value  represents a more modular structure).   source", 
            "title": "Select the best partition"
        }, 
        {
            "location": "/community/modularity/#network-roles", 
            "text": "#  EcologicalNetwork.networkroles     Function .  Network roles based on modularity  networkroles ( P :: Partition )   source", 
            "title": "Network roles"
        }, 
        {
            "location": "/species/specificity/", 
            "text": "Specificity\n\n\nAll measures of specificity are setup so that maximal specificity is 1, and maximal generality is 0. By default, specificity of quantitative networks is measured using the \nPDI\n index, and the specificity of deterministic networks is measured using the \nRR\n index. These two are mathematically equivalent when applied to a deterministic network.\n\n\n#\n\n\nEcologicalNetwork.specificity\n \n \nFunction\n.\n\n\nResource range\n\n\nspecificity(N::DeterministicNetwork)\n\n\n\n\n\nMeasure of specificity in a deterministic network. This returns a value between 0 and 1, where 1 indicates maximal specificity.\n\n\njulia\n N = BipartiteNetwork(eye(Bool, 10));\n\njulia\n specificity(N)[1]\n1.0\n\n\n\n\n\n\n\nPoisot, T., Canard, E., Mouquet, N., Hochberg, M.E., 2012. A comparative study of ecological specialization estimators. Methods in Ecology and Evolution 3, 537\u2013544. doi:10.1111/j.2041-210X.2011.00174.x\n\n\n\n\nsource\n\n\nPaired Differences Index\n\n\nspecificity(N::QuantitativeNetwork)\n\n\n\n\n\nMeasure of specificity in a quantitative network. This returns a value between 0 and 1, where 1 indicates maximal specificity. Note that the PDI is measured species-wise, and the maximal interaction strength of every species is set to 1.\n\n\njulia\n N = BipartiteNetwork(eye(Int64, 10));\n\njulia\n specificity(N)[1]\n1.0\n\n\n\n\n\n\n\nPoisot, T., Canard, E., Mouquet, N., Hochberg, M.E., 2012. A comparative study of ecological specialization estimators. Methods in Ecology and Evolution 3, 537\u2013544. doi:10.1111/j.2041-210X.2011.00174.x\n\n\n\n\nsource", 
            "title": "Specificity"
        }, 
        {
            "location": "/species/specificity/#specificity", 
            "text": "All measures of specificity are setup so that maximal specificity is 1, and maximal generality is 0. By default, specificity of quantitative networks is measured using the  PDI  index, and the specificity of deterministic networks is measured using the  RR  index. These two are mathematically equivalent when applied to a deterministic network.  #  EcologicalNetwork.specificity     Function .  Resource range  specificity(N::DeterministicNetwork)  Measure of specificity in a deterministic network. This returns a value between 0 and 1, where 1 indicates maximal specificity.  julia  N = BipartiteNetwork(eye(Bool, 10));\n\njulia  specificity(N)[1]\n1.0   Poisot, T., Canard, E., Mouquet, N., Hochberg, M.E., 2012. A comparative study of ecological specialization estimators. Methods in Ecology and Evolution 3, 537\u2013544. doi:10.1111/j.2041-210X.2011.00174.x   source  Paired Differences Index  specificity(N::QuantitativeNetwork)  Measure of specificity in a quantitative network. This returns a value between 0 and 1, where 1 indicates maximal specificity. Note that the PDI is measured species-wise, and the maximal interaction strength of every species is set to 1.  julia  N = BipartiteNetwork(eye(Int64, 10));\n\njulia  specificity(N)[1]\n1.0   Poisot, T., Canard, E., Mouquet, N., Hochberg, M.E., 2012. A comparative study of ecological specialization estimators. Methods in Ecology and Evolution 3, 537\u2013544. doi:10.1111/j.2041-210X.2011.00174.x   source", 
            "title": "Specificity"
        }, 
        {
            "location": "/species/centrality/", 
            "text": "Centrality\n\n\n#\n\n\nEcologicalNetwork.centrality_katz\n \n \nFunction\n.\n\n\nKatz's centrality\n\n\ncentrality_katz\n(\nN\n::\nUnipartite\n;\n \na\n::\nFloat64\n=\n0\n.\n1\n,\n \nk\n::\nInt64\n=\n5\n)\n\n\n\n\n\n\nThis measure can work on different path length (\nk\n), and give a different weight to every subsequent connection (\na\n). \nk\n must be at least 1 (only immediate neighbors are considered). \na\n (being a weight), must be positive.\n\n\njulia\n N = UnipartiteNetwork(eye(5));\n\njulia\n centrality_katz(N)\n5\u00d71 Array{Float64,2}:\n 0.2\n 0.2\n 0.2\n 0.2\n 0.2\n\n\n\n\n\n\n\nKatz, L., 1953. A new status index derived from sociometric analysis. Psychometrika 18, 39\u201343. doi:10.1007/bf02289026\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.centrality_degree\n \n \nFunction\n.\n\n\nDegree centrality\n\n\ncentrality_degree(N::UnipartiteNetwork)\n\n\n\n\n\nDegree centrality, corrected by the maximum degree (the most central species has a degree of 1).\n\n\n$C_{d}(i) = k_i / \\text{max}(\\mathbf{k})$\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.centrality_closeness\n \n \nFunction\n.\n\n\nCloseness centrality\n\n\ncentrality_closeness\n(\nN\n::\nUnipartiteNetwork\n;\n \nnmax\n::\nInt64\n=\n100\n)\n\n\n\n\n\n\nCloseness centrality is defined as:\n\n\n$C_{c}(i) = \\sum_j \\left( \\frac{n-1}{d_{ji}} \\right)$\n\n\nwhere $mathbf{d}$ is a matrix containing the lengths of the shortest paths between all pairs of species, and $n$ is the number of species.\n\n\nThe function calls \nshortest_path\n internally \u2013 the \nnmax\n argument is the maximal path length that wil be tried.\n\n\n\n\nBavelas, A., 1950. Communication Patterns in Task\u2010Oriented Groups. The Journal of the Acoustical Society of America 22, 725\u2013730. doi:10.1121/1.1906679\n\n\n\n\nsource", 
            "title": "Centrality"
        }, 
        {
            "location": "/species/centrality/#centrality", 
            "text": "#  EcologicalNetwork.centrality_katz     Function .  Katz's centrality  centrality_katz ( N :: Unipartite ;   a :: Float64 = 0 . 1 ,   k :: Int64 = 5 )   This measure can work on different path length ( k ), and give a different weight to every subsequent connection ( a ).  k  must be at least 1 (only immediate neighbors are considered).  a  (being a weight), must be positive.  julia  N = UnipartiteNetwork(eye(5));\n\njulia  centrality_katz(N)\n5\u00d71 Array{Float64,2}:\n 0.2\n 0.2\n 0.2\n 0.2\n 0.2   Katz, L., 1953. A new status index derived from sociometric analysis. Psychometrika 18, 39\u201343. doi:10.1007/bf02289026   source  #  EcologicalNetwork.centrality_degree     Function .  Degree centrality  centrality_degree(N::UnipartiteNetwork)  Degree centrality, corrected by the maximum degree (the most central species has a degree of 1).  $C_{d}(i) = k_i / \\text{max}(\\mathbf{k})$  source  #  EcologicalNetwork.centrality_closeness     Function .  Closeness centrality  centrality_closeness ( N :: UnipartiteNetwork ;   nmax :: Int64 = 100 )   Closeness centrality is defined as:  $C_{c}(i) = \\sum_j \\left( \\frac{n-1}{d_{ji}} \\right)$  where $mathbf{d}$ is a matrix containing the lengths of the shortest paths between all pairs of species, and $n$ is the number of species.  The function calls  shortest_path  internally \u2013 the  nmax  argument is the maximal path length that wil be tried.   Bavelas, A., 1950. Communication Patterns in Task\u2010Oriented Groups. The Journal of the Acoustical Society of America 22, 725\u2013730. doi:10.1121/1.1906679   source", 
            "title": "Centrality"
        }, 
        {
            "location": "/species/foodweb/", 
            "text": "Food-web specific measures\n\n\n\n\nMeasures of trophic level\n\n\nThese measure work by counting the distance to a primary producer \u2013 where \"primary producer\" is defined as the fact of not having outgoing interactions. Primary producers have a trophic level of 1, and species that consume primary producers have trophic levels of 2, etc. This represents a species' \nfractional\n trophic level.\n\n\n#\n\n\nEcologicalNetwork.fractional_trophic_level\n \n \nFunction\n.\n\n\nFractional trophic level\n\n\nfractional_trophic_level(N::Union{UnipartiteNetwork, UnipartiteQuantiNetwork})\n\n\n\n\n\nAs defined by Pauly \n Palomares.\n\n\nThis function takes a unipartite network, either deterministic or quantitative, as its input. There is currently no trophic rank formulation for probabilistic networks.\n\n\nThe primary producers have a rank of 1, and species consuming any species of maximal level $n$ have level $n+1$.\n\n\nNote that the trophic level is measured on the network with self-interactions removed.\n\n\njulia\n stony() |\n fractional_trophic_level |\n maximum\n5.0\n\njulia\n stony() |\n fractional_trophic_level |\n minimum\n1.0\n\n\n\n\n\n\n\nPauly, D., Palomares, M.-L., 2005. Fishing down marine food web: it is far more pervasive than we thought. Bulletin of Marine Science 76, 197\u2013212.\n\n\n\n\nsource\n\n\nBecause some species higher-up the food chain eat preys at various fractional trophic levels, there is also a more integrative measure \u2013 the trophic level of a species is the weighted average of the fractional trophic level of its preys:\n\n\n#\n\n\nEcologicalNetwork.trophic_level\n \n \nFunction\n.\n\n\nTrophic level\n\n\ntrophic_level(N::Union{UnipartiteNetwork, UnipartiteQuantiNetwork})\n\n\n\n\n\nAs defined by Pauly \n Palomares.\n\n\nThis function weighs the fractional trophic level as returned by \nfractional_trophic_level\n by the proportion of the prey in the predator's diet. Specifically, this is done with:\n\n\n$\\text{TL}\ni = 1 + \\sum\n}\u00a0\\left(\\mathbf{f}\nj\\times\\mathbf{D}\n\\right)$\n\n\nThe $\\mathbf{j}$ array has the fractional trophic levels, and $mathbf{D}$ is the matrix with diet proportions. $\\mathbf{D}\n{ij}$ is $0.0$ for all non-consumed preys. In a quantitative network, it is $\\mathbf{A}\n/\\sum\\mathbf{A}\n{i\\dot}$, and it is the same in deterministic networks although it works out to $1 / k\n(i)$ in the end.\n\n\nAs for \nfractional_trophic_level\n, this function is applied to the network without self-edges.\n\n\n\n\nPauly, D., Palomares, M.-L., 2005. Fishing down marine food web: it is far more pervasive than we thought. Bulletin of Marine Science 76, 197\u2013212.\n\n\n\n\nsource\n\n\n\n\nMeasures of trophic positions\n\n\nFor every species in a food web, this will return an array with its overall position:\n\n\n#\n\n\nEcologicalNetwork.foodweb_position\n \n \nFunction\n.\n\n\nRelative food web position\n\n\nfoodweb_position(N::UnipartiteNetwork)\n\n\n\n\n\nReturns the trophic positions (\n:top\n, \n:intermediate\n, or \n:bottom\n) of species in a food web. Uses a keyword argument \nloops\n to decide whether self-interactions should count \u2013 this is \nfalse\n by default, so the network is used without self-interactions.\n\n\nsource\n\n\nRelative food web position\n\n\nfoodweb_position\n(\nN\n::\nUnipartiteQuantiNetwork\n;\n \nloops\n::\nBool\n=\nfalse\n)\n\n\n\n\n\n\nReturns the trophic position based on the adjacency matrix.\n\n\nsource", 
            "title": "Food-web specific"
        }, 
        {
            "location": "/species/foodweb/#food-web-specific-measures", 
            "text": "", 
            "title": "Food-web specific measures"
        }, 
        {
            "location": "/species/foodweb/#measures-of-trophic-level", 
            "text": "These measure work by counting the distance to a primary producer \u2013 where \"primary producer\" is defined as the fact of not having outgoing interactions. Primary producers have a trophic level of 1, and species that consume primary producers have trophic levels of 2, etc. This represents a species'  fractional  trophic level.  #  EcologicalNetwork.fractional_trophic_level     Function .  Fractional trophic level  fractional_trophic_level(N::Union{UnipartiteNetwork, UnipartiteQuantiNetwork})  As defined by Pauly   Palomares.  This function takes a unipartite network, either deterministic or quantitative, as its input. There is currently no trophic rank formulation for probabilistic networks.  The primary producers have a rank of 1, and species consuming any species of maximal level $n$ have level $n+1$.  Note that the trophic level is measured on the network with self-interactions removed.  julia  stony() |  fractional_trophic_level |  maximum\n5.0\n\njulia  stony() |  fractional_trophic_level |  minimum\n1.0   Pauly, D., Palomares, M.-L., 2005. Fishing down marine food web: it is far more pervasive than we thought. Bulletin of Marine Science 76, 197\u2013212.   source  Because some species higher-up the food chain eat preys at various fractional trophic levels, there is also a more integrative measure \u2013 the trophic level of a species is the weighted average of the fractional trophic level of its preys:  #  EcologicalNetwork.trophic_level     Function .  Trophic level  trophic_level(N::Union{UnipartiteNetwork, UnipartiteQuantiNetwork})  As defined by Pauly   Palomares.  This function weighs the fractional trophic level as returned by  fractional_trophic_level  by the proportion of the prey in the predator's diet. Specifically, this is done with:  $\\text{TL} i = 1 + \\sum }\u00a0\\left(\\mathbf{f} j\\times\\mathbf{D} \\right)$  The $\\mathbf{j}$ array has the fractional trophic levels, and $mathbf{D}$ is the matrix with diet proportions. $\\mathbf{D} {ij}$ is $0.0$ for all non-consumed preys. In a quantitative network, it is $\\mathbf{A} /\\sum\\mathbf{A} {i\\dot}$, and it is the same in deterministic networks although it works out to $1 / k (i)$ in the end.  As for  fractional_trophic_level , this function is applied to the network without self-edges.   Pauly, D., Palomares, M.-L., 2005. Fishing down marine food web: it is far more pervasive than we thought. Bulletin of Marine Science 76, 197\u2013212.   source", 
            "title": "Measures of trophic level"
        }, 
        {
            "location": "/species/foodweb/#measures-of-trophic-positions", 
            "text": "For every species in a food web, this will return an array with its overall position:  #  EcologicalNetwork.foodweb_position     Function .  Relative food web position  foodweb_position(N::UnipartiteNetwork)  Returns the trophic positions ( :top ,  :intermediate , or  :bottom ) of species in a food web. Uses a keyword argument  loops  to decide whether self-interactions should count \u2013 this is  false  by default, so the network is used without self-interactions.  source  Relative food web position  foodweb_position ( N :: UnipartiteQuantiNetwork ;   loops :: Bool = false )   Returns the trophic position based on the adjacency matrix.  source", 
            "title": "Measures of trophic positions"
        }, 
        {
            "location": "/nhst/nullmodels/", 
            "text": "Null models\n\n\nEcologicalNetwork\n offers a number of ways to draw random binary networks from a template of probabilities. This is useful to generate networks under a null model, for example. All these functions will respect the fact that the network in bipartite or unipartite.\n\n\n\n\nCreating a deterministic network from a probabilistic network\n\n\nThere are a number of ways to generate a deterministic network from a probabilistic one. All of these functions take a network on a class belonging to \nProbabilisticNetwork\n, and return a network of a class belonging to \nDeterministicNetwork\n.\n\n\n\n\nConvert to deterministic\n\n\nThe first is simply to assing \ntrue\n to all interactions with a non-0 probability, and \nfalse\n to the others. This is done with the \nmake_binary\n function:\n\n\nN\n \n=\n \nUnipartiteProbaNetwork\n(\neye\n(\n3\n))\n\n\nB\n \n=\n \nmake_binary\n(\nN\n)\n\n\nB\n.\nA\n\n\n\n\n\n\n3\u00d73 Array{Bool,2}:\n  true  false  false\n false   true  false\n false  false   true\n\n\n\n\n\n#\n\n\nEcologicalNetwork.make_binary\n \n \nFunction\n.\n\n\nReturns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is greater than 0.\n\n\nsource\n\n\n\n\nUsing a threshold\n\n\nThe second way is to determine a cutoff for probabilities, below which they will be assigned \nfalse\n. This is done through \nmake_threshold\n:\n\n\nN\n \n=\n \nUnipartiteProbaNetwork\n(\nrand\n((\n4\n,\n \n4\n)))\n\n\nB\n \n=\n \nmake_threshold\n(\nN\n,\n \n0.5\n)\n\n\nB\n.\nA\n\n\n\n\n\n\n4\u00d74 Array{Bool,2}:\n  true  true  false  false\n false  true  false  false\n false  true   true   true\n false  true  false   true\n\n\n\n\n\n#\n\n\nEcologicalNetwork.make_threshold\n \n \nFunction\n.\n\n\nReturns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is \n \nk\n. This is probably unwise to use this function since this practice is of questionnable relevance, but it is included for the sake of exhaustivity.\n\n\nk\n must be in [0;1[.\n\n\nsource\n\n\n\n\nRandom draws\n\n\nThe last way to convert a probabilistic network to a deterministic one is to perform one random draw for each interaction. In this scenario, \ntrue\n is assigned with a probability $P_{ij}$. This is done with the \nmake_bernoulli\n function:\n\n\nN\n \n=\n \nBipartiteProbaNetwork\n(\nrand\n((\n4\n,\n \n4\n)))\n\n\nB\n \n=\n \nmake_bernoulli\n(\nN\n)\n\n\nB\n.\nA\n\n\n\n\n\n\n4\u00d74 Array{Bool,2}:\n true  false   true  false\n true  false   true  false\n true  false   true  false\n true  false  false  false\n\n\n\n\n\n#\n\n\nEcologicalNetwork.make_bernoulli\n \n \nFunction\n.\n\n\nReturns a matrix B of the same size as A, in which each element B(i,j) is 1 with probability A(i,j).\n\n\nsource\n\n\n\n\nCreating a probabilistic network from a deterministic network\n\n\nThe inverse operation can be done using the \nnullX\n functions. These functions use informations about the degree distribution to generate probabilistic networks:\n\n\n#\n\n\nEcologicalNetwork.null1\n \n \nFunction\n.\n\n\nType I null model\n\n\nnull1(N::DeterministicNetwork)\n\n\n\n\n\nGiven a matrix \nA\n, \nnull1(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the connectance of \nA\n.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null2\n \n \nFunction\n.\n\n\nType II null model\n\n\nnull2(N::DeterministicNetwork)\n\n\n\n\n\nGiven a matrix \nA\n, \nnull2(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the degree of each species.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null3in\n \n \nFunction\n.\n\n\nType IIIin null model\n\n\nnull3in(N::DeterministicNetwork)\n\n\n\n\n\nGiven a matrix \nA\n, \nnull3in(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the in-degree (number of predecessors) of each species, divided by the total number of possible predecessors.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null3out\n \n \nFunction\n.\n\n\nType IIIout null model\n\n\nnull3out(N::DeterministicNetwork)\n\n\n\n\n\nGiven a matrix \nA\n, \nnull3out(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the out-degree (number of successors) of each species, divided by the total number of possible successors.\n\n\nsource\n\n\nFor an example:\n\n\nN\n \n=\n \nmake_bernoulli\n(\nBipartiteProbaNetwork\n(\nrand\n(\n3\n,\n \n5\n)))\n\n\nnull2\n(\nN\n)\n.\nA\n\n\n\n\n\n\n3\u00d75 Array{Float64,2}:\n 0.666667  1.0  0.666667  0.666667  0.833333\n 0.366667  0.7  0.366667  0.366667  0.533333\n 0.266667  0.6  0.266667  0.266667  0.433333\n\n\n\n\n\n\n\nNull model wrapper\n\n\nEcologicalNetwork\n has a wrapper to generate an arbitrary number of Bernoulli networks from a probability matrix. This approach is encourage over simply generating your own networks, because the wrapper will make sure that all networks have no species without any interactions. This ensures that the networks have the same size.\n\n\nFor example, we can generate a hundred replicates from the \nstony\n food web dataset, using the type 2 model:\n\n\ntemplate\n \n=\n \nnull2\n(\nstony\n())\n\n\n\n# Generate up to 100 networks\n\n\nN\n \n=\n \nnullmodel\n(\ntemplate\n,\n \nn\n=\n100\n,\n \nmax\n=\n1000\n)\n\n\n\n# Average connectance\n\n\nmean\n(\nmap\n(\nconnectance\n,\n \nN\n))\n\n\n\n\n\n\n0.06625797193877551\n\n\n\n\n\nIt must be noted that the number of networks returned by \nnullmodel\n may be \nlower\n than the requested number of networks. This is because of the constraint on the fact that no species can end up without interactions. When this constrained is enforced, some networks have very low success rates. This can be measured using the \nspecies_is_free\n function:\n\n\ntemplate\n \n=\n \nnull2\n(\nmcmullen\n())\n\n\n\n# Probability that every species has at least one interaction\n\n\nat_least_one\n \n=\n \n1.\n-\nspecies_is_free\n(\nmake_unipartite\n(\ntemplate\n))\n\n\n\n# Probability that a randomized network has no unconnected species\n\n\nprod\n(\nat_least_one\n)\n\n\n\n\n\n\n1.1674941263628132e-10\n\n\n\n\n\n#\n\n\nEcologicalNetwork.nullmodel\n \n \nFunction\n.\n\n\nGeneration of random matrices from a null model\n\n\nnullmodel\n(\nN\n::\nProbabilisticNetwork\n;\n \nn\n=\n1000\n,\n \nmax\n=\n10000\n)\n\n\n\n\n\n\nThis function is a wrapper to generate replicated binary matrices from a template probability matrix \nA\n.\n\n\nIf you use julia on more than one CPU, \ni.e.\n if you started it with \njulia -p k\n where \nk\n is more than 1, this function will distribute each trial to one worker. Which means that it's fast.\n\n\n\n\nn\n (def. 1000), number of replicates to generate\n\n\nmax\n (def. 10000), number of trials to make\n\n\n\n\nsource", 
            "title": "Probabilistic null models"
        }, 
        {
            "location": "/nhst/nullmodels/#null-models", 
            "text": "EcologicalNetwork  offers a number of ways to draw random binary networks from a template of probabilities. This is useful to generate networks under a null model, for example. All these functions will respect the fact that the network in bipartite or unipartite.", 
            "title": "Null models"
        }, 
        {
            "location": "/nhst/nullmodels/#creating-a-deterministic-network-from-a-probabilistic-network", 
            "text": "There are a number of ways to generate a deterministic network from a probabilistic one. All of these functions take a network on a class belonging to  ProbabilisticNetwork , and return a network of a class belonging to  DeterministicNetwork .", 
            "title": "Creating a deterministic network from a probabilistic network"
        }, 
        {
            "location": "/nhst/nullmodels/#convert-to-deterministic", 
            "text": "The first is simply to assing  true  to all interactions with a non-0 probability, and  false  to the others. This is done with the  make_binary  function:  N   =   UnipartiteProbaNetwork ( eye ( 3 ))  B   =   make_binary ( N )  B . A   3\u00d73 Array{Bool,2}:\n  true  false  false\n false   true  false\n false  false   true  #  EcologicalNetwork.make_binary     Function .  Returns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is greater than 0.  source", 
            "title": "Convert to deterministic"
        }, 
        {
            "location": "/nhst/nullmodels/#using-a-threshold", 
            "text": "The second way is to determine a cutoff for probabilities, below which they will be assigned  false . This is done through  make_threshold :  N   =   UnipartiteProbaNetwork ( rand (( 4 ,   4 )))  B   =   make_threshold ( N ,   0.5 )  B . A   4\u00d74 Array{Bool,2}:\n  true  true  false  false\n false  true  false  false\n false  true   true   true\n false  true  false   true  #  EcologicalNetwork.make_threshold     Function .  Returns a matrix B of the same size as A, in which each element B(i,j) is 1 if A(i,j) is    k . This is probably unwise to use this function since this practice is of questionnable relevance, but it is included for the sake of exhaustivity.  k  must be in [0;1[.  source", 
            "title": "Using a threshold"
        }, 
        {
            "location": "/nhst/nullmodels/#random-draws", 
            "text": "The last way to convert a probabilistic network to a deterministic one is to perform one random draw for each interaction. In this scenario,  true  is assigned with a probability $P_{ij}$. This is done with the  make_bernoulli  function:  N   =   BipartiteProbaNetwork ( rand (( 4 ,   4 )))  B   =   make_bernoulli ( N )  B . A   4\u00d74 Array{Bool,2}:\n true  false   true  false\n true  false   true  false\n true  false   true  false\n true  false  false  false  #  EcologicalNetwork.make_bernoulli     Function .  Returns a matrix B of the same size as A, in which each element B(i,j) is 1 with probability A(i,j).  source", 
            "title": "Random draws"
        }, 
        {
            "location": "/nhst/nullmodels/#creating-a-probabilistic-network-from-a-deterministic-network", 
            "text": "The inverse operation can be done using the  nullX  functions. These functions use informations about the degree distribution to generate probabilistic networks:  #  EcologicalNetwork.null1     Function .  Type I null model  null1(N::DeterministicNetwork)  Given a matrix  A ,  null1(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the connectance of  A .  source  #  EcologicalNetwork.null2     Function .  Type II null model  null2(N::DeterministicNetwork)  Given a matrix  A ,  null2(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the degree of each species.  source  #  EcologicalNetwork.null3in     Function .  Type IIIin null model  null3in(N::DeterministicNetwork)  Given a matrix  A ,  null3in(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the in-degree (number of predecessors) of each species, divided by the total number of possible predecessors.  source  #  EcologicalNetwork.null3out     Function .  Type IIIout null model  null3out(N::DeterministicNetwork)  Given a matrix  A ,  null3out(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the out-degree (number of successors) of each species, divided by the total number of possible successors.  source  For an example:  N   =   make_bernoulli ( BipartiteProbaNetwork ( rand ( 3 ,   5 )))  null2 ( N ) . A   3\u00d75 Array{Float64,2}:\n 0.666667  1.0  0.666667  0.666667  0.833333\n 0.366667  0.7  0.366667  0.366667  0.533333\n 0.266667  0.6  0.266667  0.266667  0.433333", 
            "title": "Creating a probabilistic network from a deterministic network"
        }, 
        {
            "location": "/nhst/nullmodels/#null-model-wrapper", 
            "text": "EcologicalNetwork  has a wrapper to generate an arbitrary number of Bernoulli networks from a probability matrix. This approach is encourage over simply generating your own networks, because the wrapper will make sure that all networks have no species without any interactions. This ensures that the networks have the same size.  For example, we can generate a hundred replicates from the  stony  food web dataset, using the type 2 model:  template   =   null2 ( stony ())  # Generate up to 100 networks  N   =   nullmodel ( template ,   n = 100 ,   max = 1000 )  # Average connectance  mean ( map ( connectance ,   N ))   0.06625797193877551  It must be noted that the number of networks returned by  nullmodel  may be  lower  than the requested number of networks. This is because of the constraint on the fact that no species can end up without interactions. When this constrained is enforced, some networks have very low success rates. This can be measured using the  species_is_free  function:  template   =   null2 ( mcmullen ())  # Probability that every species has at least one interaction  at_least_one   =   1. - species_is_free ( make_unipartite ( template ))  # Probability that a randomized network has no unconnected species  prod ( at_least_one )   1.1674941263628132e-10  #  EcologicalNetwork.nullmodel     Function .  Generation of random matrices from a null model  nullmodel ( N :: ProbabilisticNetwork ;   n = 1000 ,   max = 10000 )   This function is a wrapper to generate replicated binary matrices from a template probability matrix  A .  If you use julia on more than one CPU,  i.e.  if you started it with  julia -p k  where  k  is more than 1, this function will distribute each trial to one worker. Which means that it's fast.   n  (def. 1000), number of replicates to generate  max  (def. 10000), number of trials to make   source", 
            "title": "Null model wrapper"
        }, 
        {
            "location": "/nhst/swaps/", 
            "text": "Network permutations\n\n\nAs opposed to re-generating networks from a template of probabilities, network permutations shuffles interactions within a network. This is done by enforcing different constraints on degree distribution: either only the fill is maintained, or only the in or out degree, or both.\n\n\n#\n\n\nEcologicalNetwork.swaps\n \n \nFunction\n.\n\n\nGenerates permutations of a network\n\n\nswaps\n(\nN\n::\nDeterministicNetwork\n,\n \nr\n::\nInt64\n;\n \nconstraint\n::\nSymbol\n=\n:\ndegree\n,\n \nswapsize\n::\nInt64\n=\n3\n,\n \nn\n::\nInt64\n=\n3000\n)\n\n\n\n\n\n\nBy default, this method will look for random (x, x) sub-matrices, where x is given by the \nswapsize\n keyword, and shuffle them. There are four possible constraints:\n\n\n\n\n\n\n\n\nvalue\n\n\nmeaning\n\n\nproba equivalent\n\n\n\n\n\n\n\n\n\n\n:degree\n\n\nboth in and out degree\n\n\nnull2\n\n\n\n\n\n\n:generality\n\n\nonly out degree\n\n\nnull3out\n\n\n\n\n\n\n:vulnerability\n\n\nonly in degree\n\n\nnull3in\n\n\n\n\n\n\n:fill\n\n\nonly number of links\n\n\nnull1\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nN\n, a \nDeterministicNetwork\n\n\nr\n, the number of randomized networks to generate\n\n\n\n\nKeywords:\n\n\n\n\nconstraint\n: can be \n:degree\n, \n:generality\n, \n:vulnerability\n, or \n:fill\n\n\nswapsize\n: the size of the square sub-matrix to swap (defaults to 3)\n\n\nn\n: the number of sub-matrices to swap (defaults to 3000)\n\n\n\n\nsource\n\n\nIt is also possible to produce a single permutation of a network if needed.\n\n\n#\n\n\nEcologicalNetwork.swap\n \n \nFunction\n.\n\n\nSwaps a unipartite network while enforcing a constraint on degree distribution.\n\n\nsource\n\n\nGenerate a single permutation of a network\n\n\nswap\n(\nN\n::\nBipartiteNetwork\n;\n \nconstraint\n::\nSymbol\n=\n:\ndegree\n,\n \nswapsize\n::\nInt64\n=\n3\n,\n \nn\n::\nInt64\n=\n3000\n)\n\n\n\n\n\n\nSwaps a bipartite network while enforcing a constraint on degree distribution. See the documentation for \nswaps\n for the complete explanation of arguments.\n\n\nsource", 
            "title": "Network permutations"
        }, 
        {
            "location": "/nhst/swaps/#network-permutations", 
            "text": "As opposed to re-generating networks from a template of probabilities, network permutations shuffles interactions within a network. This is done by enforcing different constraints on degree distribution: either only the fill is maintained, or only the in or out degree, or both.  #  EcologicalNetwork.swaps     Function .  Generates permutations of a network  swaps ( N :: DeterministicNetwork ,   r :: Int64 ;   constraint :: Symbol = : degree ,   swapsize :: Int64 = 3 ,   n :: Int64 = 3000 )   By default, this method will look for random (x, x) sub-matrices, where x is given by the  swapsize  keyword, and shuffle them. There are four possible constraints:     value  meaning  proba equivalent      :degree  both in and out degree  null2    :generality  only out degree  null3out    :vulnerability  only in degree  null3in    :fill  only number of links  null1     Arguments:   N , a  DeterministicNetwork  r , the number of randomized networks to generate   Keywords:   constraint : can be  :degree ,  :generality ,  :vulnerability , or  :fill  swapsize : the size of the square sub-matrix to swap (defaults to 3)  n : the number of sub-matrices to swap (defaults to 3000)   source  It is also possible to produce a single permutation of a network if needed.  #  EcologicalNetwork.swap     Function .  Swaps a unipartite network while enforcing a constraint on degree distribution.  source  Generate a single permutation of a network  swap ( N :: BipartiteNetwork ;   constraint :: Symbol = : degree ,   swapsize :: Int64 = 3 ,   n :: Int64 = 3000 )   Swaps a bipartite network while enforcing a constraint on degree distribution. See the documentation for  swaps  for the complete explanation of arguments.  source", 
            "title": "Network permutations"
        }, 
        {
            "location": "/nhst/nhst/", 
            "text": "Null Hypothesis Significance Testing\n\n\nNHST is used to determine whether the observed value of a network measure is larger, or smaller, or similar to, what is expected by chance. The function to perform a test is typically applied after you have generated randomized networks using either null models or network permutations.\n\n\n#\n\n\nEcologicalNetwork.test_network_property\n \n \nFunction\n.\n\n\nNull Hypothesis Significance Testing\n\n\ntest_network_property\n(\nN\n::\nEcoNetwork\n,\n \nf\n,\n \nS\n;\n \ntest\n::\nSymbol\n=\n:\ngreater\n)\n\n\n\n\n\n\nTest whether the observed value (through applying a function \nf\n) on an empirical network \nN\n differs from the distribution derived from measuring the same value on a collection of randomized networks \nS\n. \nS\n is an array of networks of the same type as \nN\n.\n\n\nThere are two possible values for the \ntest\n keyword argument: \n:greater\n and \n:smaller\n. The test is one-tailed. The results are returned as a \nNetworkTestOutput\n object (see \n?EcologicalNetwork.NetworkTestOutput\n for the complete edocumentation).\n\n\nThe \np\n-value (\npval\n) is measured by counting the proportion of networks with a larger (resp. smaller) value of the measure than the original network, as in normal permutation tests.\n\n\nThe original value of the measure is given (\nv0\n), as well as the \nz\n-scores (\nz\n) of all randomized networks.\n\n\nsource\n\n\nThe output is a \nNetworkTestOutput\n object, with a number of fields.\n\n\n#\n\n\nEcologicalNetwork.NetworkTestOutput\n \n \nType\n.\n\n\nOutput of a permutation-based test\n\n\n\n\npval\n \u2013 the test p-value\n\n\ntest\n \u2013 the type of test (\n:smaller\n or \n:greater\n)\n\n\nv0\n \u2013 the measure of the empirical network\n\n\nn\n \u2013 the number of randomized networks used\n\n\nhits\n \u2013 the number of randomized network matching the test condition\n\n\nz\n \u2013 the \nz\n-scores of the statistics for each randomized network\n\n\n\n\nsource", 
            "title": "Null Hypothesis Significance Testing"
        }, 
        {
            "location": "/nhst/nhst/#null-hypothesis-significance-testing", 
            "text": "NHST is used to determine whether the observed value of a network measure is larger, or smaller, or similar to, what is expected by chance. The function to perform a test is typically applied after you have generated randomized networks using either null models or network permutations.  #  EcologicalNetwork.test_network_property     Function .  Null Hypothesis Significance Testing  test_network_property ( N :: EcoNetwork ,   f ,   S ;   test :: Symbol = : greater )   Test whether the observed value (through applying a function  f ) on an empirical network  N  differs from the distribution derived from measuring the same value on a collection of randomized networks  S .  S  is an array of networks of the same type as  N .  There are two possible values for the  test  keyword argument:  :greater  and  :smaller . The test is one-tailed. The results are returned as a  NetworkTestOutput  object (see  ?EcologicalNetwork.NetworkTestOutput  for the complete edocumentation).  The  p -value ( pval ) is measured by counting the proportion of networks with a larger (resp. smaller) value of the measure than the original network, as in normal permutation tests.  The original value of the measure is given ( v0 ), as well as the  z -scores ( z ) of all randomized networks.  source  The output is a  NetworkTestOutput  object, with a number of fields.  #  EcologicalNetwork.NetworkTestOutput     Type .  Output of a permutation-based test   pval  \u2013 the test p-value  test  \u2013 the type of test ( :smaller  or  :greater )  v0  \u2013 the measure of the empirical network  n  \u2013 the number of randomized networks used  hits  \u2013 the number of randomized network matching the test condition  z  \u2013 the  z -scores of the statistics for each randomized network   source", 
            "title": "Null Hypothesis Significance Testing"
        }
    ]
}