{
    "docs": [
        {
            "location": "/", 
            "text": "EcologicalNetwork\n\n\nThis package provides a common interface for the analysis of ecological networks, using \njulia\n. It is \nvery\n opinionated about the \"right\" way to do things, but we have documented our opinions in several publications (see the references at the bottom of this page).\n\n\n\n\nPackage philosophy\n\n\nThe package is built around a typesystem for networks, which is intended to capture the different types of data and communities ecologists need to handle. This makes the package extensible, both by writing additional methods with a very fine-tuned dispatch, or by adding additional types that should work out of the box (or be very close to).\n\n\nThis package is a \nlibrary\n for the analysis of ecological networks. On purpose, we do not provide \"wrapper\"-type functions that would perform an entire analysis. We experimented with this idea during development, and rapidly realized that even for the most simple research project, we needed to make small tweaks that made the wrappers a nuisance. We decided to give you lego blocks, and it's your job to build the kick-ass spaceship.\n\n\nWe tried to avoid making the package into yet another Domain Specific Language. This means that when an operation should be expressed using the julian syntax, we made it this way. Transforming networks from a type to another is done with \nconvert\n. Random networks are drawn with \nrand\n. Swapping of interactions is done with \nshuffle\n. There is support for slicing of networks, as well as the entire operations on sets. A lot of methods from \nBase\n have been overloaded, and this \nshould\n make the code easy to write and read.\n\n\n\n\nWhy should I use this package?\n\n\nIt offers a single interface to analyse almost all type of networks for ecology. It's somewhat fast (very specialized packages are likely to be faster). It's built around the very best practices in network analysis. We think the type system is very cool. It's very well tested and adequately documented. We used it for research and teaching for months before releasing it. It's actively maintained and we will keep adding functionalities.\n\n\nYou don't have to use it if you don't want to.\n\n\n\n\nBut it doesn't even make figures!\n\n\nThis is coming soon.\n\n\n\n\nAnd it doesn't even generate random networks!\n\n\nThis is coming sooner.\n\n\n\n\nAnd worse, you forgot my favorite method!\n\n\nYeah, about that. We probably didn't.\n\n\nA lot of methods were considered for inclusion in the package, but ultimately discarded because we were not 100% confident in their robustness, reliability, validity, or interpretation. As we said, the package is \nvery\n opinionated about the right way to do things, and new functions require more time for maintenance and testing; it makes sense for us to focus on things we trust.\n\n\nIf your favorite measure or method is missing, there are two solutions. First, this package is essentialy a library of functions to build network analyses, so you can use this to create a function that does what you want. For example, if you want to take the square root of a quantitative network, you can overload the \n\u221a\n method from base this way:\n\n\nimport Base: \u221a\n\nfunction \u221a(N::T) where {T \n: QuantitativeNetwork}\n  # Get the new type for the output\n  NewType = T \n: AbstractBipartiteNetwork ? BipartiteQuantitativeNetwork : UnipartiteQuantitativeNetwork\n  # Take the square root of the interaction strength\n  sqrt_matrix = sqrt.(N.A)\n  # Return a new network with the correct types\n  return NewType{typeof(sqrt_matrix),eltype(N)[2]}(sqrt_matrix, EcologicalNetwork.species_objects(N)...)\nend\n\n\n\n\nThe second solution (which is actually a second \nstep\n after you have been writing your own method), is to submit a pull request to the package, to have your new methods available in the next release. Currently, we will be very selective about which methods are added. In the future (presumably shortly after the release of \nJulia\n \nv1.0\n), we will start a companion package to provide additional methods.\n\n\n\n\nReferences\n\n\nAbout the analysis of ecological networks in general, the package covers (or will cover over time) most of the measures we identified as robust in the following publication:\n\n\nDelmas, Eva, Mathilde Besson, Marie-Helene Brice, Laura Burkle, Giulio V. Dalla Riva, Marie-Jos\u00e9e Fortin, Dominique Gravel, et al. \u201cAnalyzing Ecological Networks of Species Interactions.\u201d BioRxiv, (2017), 112540. https://doi.org/10.1101/112540.\n\n\nWe highly recommend we keep it nearby when using the package. A lot of decisions taken during development are grounded in the analysis of the literature we conducted over a few years.\n\n\n\n\nNetwork \u03b2-diversity\n\n\nThe analysis of network dissimilarity is done exactly as described in:\n\n\nPoisot, Timoth\u00e9e, Elsa Canard, David Mouillot, Nicolas Mouquet, and Dominique Gravel. \u201cThe Dissimilarity of Species Interaction Networks.\u201d Ecology Letters 15, no. 12 (2012): 1353\u20131361. https://doi.org/10.1111/ele.12002.\n\n\nThe measures for \u03b2-diversity (and the approach of partitioning variation in sets) is done exactly as described in:\n\n\nKoleff, Patricia, Kevin J. Gaston, and Jack J. Lennon. \u201cMeasuring Beta Diversity for Presence\u2013absence Data.\u201d Journal of Animal Ecology 72, no. 3 (2003): 367\u201382. https://doi.org/10.1046/j.1365-2656.2003.00710.x.\n\n\nThe functions presented in their table are implemented as \nKGLXX\n, where \nXX\n is the number of the function on two digits (\ni.e.\n the second measure of \u03b2-diversity is \nKGL02\n).\n\n\n\n\nSpecificity\n\n\nPoisot, Timothee, Elsa Canard, Nicolas Mouquet, and Michael E Hochberg. \u201cA Comparative Study of Ecological Specialization Estimators.\u201d Methods in Ecology and Evolution 3, no. 3 (2012): 537\u201344. https://doi.org/10.1111/j.2041-210X.2011.00174.x.\n\n\n\n\nProbabilistic networks\n\n\nPoisot, Timoth\u00e9e, Alyssa R. Cirtwill, K\u00e9vin Cazelles, Dominique Gravel, Marie-Jos\u00e9e Fortin, and Daniel B. Stouffer. \u201cThe Structure of Probabilistic Networks.\u201d Methods in Ecology and Evolution 7, no. 3 (2016): 303\u201312. https://doi.org/10.1111/2041-210X.12468.\n\n\n\n\nHow can I contribute?\n\n\nGood question!\n\n\nThe easiest way to contribute is to use the package, and \nopen an issue\n whenever you can't manage to do something, think the syntax is not clear, or the documentation is confusing. This is seriously one of the best ways to help.\n\n\nIf you want to contribute code, you can fork this repository, and start adding the functions you want, or changing the code. Please work from the \ndevelop\n branch (\nmaster\n does not accept pull requests except from maintainers, and cannot be pushed to unless a series of conditions are met). It's better if all of your code is tested and documented, but we will work with you when receiving the pull request anyways.", 
            "title": "Home"
        }, 
        {
            "location": "/#ecologicalnetwork", 
            "text": "This package provides a common interface for the analysis of ecological networks, using  julia . It is  very  opinionated about the \"right\" way to do things, but we have documented our opinions in several publications (see the references at the bottom of this page).", 
            "title": "EcologicalNetwork"
        }, 
        {
            "location": "/#package-philosophy", 
            "text": "The package is built around a typesystem for networks, which is intended to capture the different types of data and communities ecologists need to handle. This makes the package extensible, both by writing additional methods with a very fine-tuned dispatch, or by adding additional types that should work out of the box (or be very close to).  This package is a  library  for the analysis of ecological networks. On purpose, we do not provide \"wrapper\"-type functions that would perform an entire analysis. We experimented with this idea during development, and rapidly realized that even for the most simple research project, we needed to make small tweaks that made the wrappers a nuisance. We decided to give you lego blocks, and it's your job to build the kick-ass spaceship.  We tried to avoid making the package into yet another Domain Specific Language. This means that when an operation should be expressed using the julian syntax, we made it this way. Transforming networks from a type to another is done with  convert . Random networks are drawn with  rand . Swapping of interactions is done with  shuffle . There is support for slicing of networks, as well as the entire operations on sets. A lot of methods from  Base  have been overloaded, and this  should  make the code easy to write and read.", 
            "title": "Package philosophy"
        }, 
        {
            "location": "/#why-should-i-use-this-package", 
            "text": "It offers a single interface to analyse almost all type of networks for ecology. It's somewhat fast (very specialized packages are likely to be faster). It's built around the very best practices in network analysis. We think the type system is very cool. It's very well tested and adequately documented. We used it for research and teaching for months before releasing it. It's actively maintained and we will keep adding functionalities.  You don't have to use it if you don't want to.", 
            "title": "Why should I use this package?"
        }, 
        {
            "location": "/#but-it-doesnt-even-make-figures", 
            "text": "This is coming soon.", 
            "title": "But it doesn't even make figures!"
        }, 
        {
            "location": "/#and-it-doesnt-even-generate-random-networks", 
            "text": "This is coming sooner.", 
            "title": "And it doesn't even generate random networks!"
        }, 
        {
            "location": "/#and-worse-you-forgot-my-favorite-method", 
            "text": "Yeah, about that. We probably didn't.  A lot of methods were considered for inclusion in the package, but ultimately discarded because we were not 100% confident in their robustness, reliability, validity, or interpretation. As we said, the package is  very  opinionated about the right way to do things, and new functions require more time for maintenance and testing; it makes sense for us to focus on things we trust.  If your favorite measure or method is missing, there are two solutions. First, this package is essentialy a library of functions to build network analyses, so you can use this to create a function that does what you want. For example, if you want to take the square root of a quantitative network, you can overload the  \u221a  method from base this way:  import Base: \u221a\n\nfunction \u221a(N::T) where {T  : QuantitativeNetwork}\n  # Get the new type for the output\n  NewType = T  : AbstractBipartiteNetwork ? BipartiteQuantitativeNetwork : UnipartiteQuantitativeNetwork\n  # Take the square root of the interaction strength\n  sqrt_matrix = sqrt.(N.A)\n  # Return a new network with the correct types\n  return NewType{typeof(sqrt_matrix),eltype(N)[2]}(sqrt_matrix, EcologicalNetwork.species_objects(N)...)\nend  The second solution (which is actually a second  step  after you have been writing your own method), is to submit a pull request to the package, to have your new methods available in the next release. Currently, we will be very selective about which methods are added. In the future (presumably shortly after the release of  Julia   v1.0 ), we will start a companion package to provide additional methods.", 
            "title": "And worse, you forgot my favorite method!"
        }, 
        {
            "location": "/#references", 
            "text": "About the analysis of ecological networks in general, the package covers (or will cover over time) most of the measures we identified as robust in the following publication:  Delmas, Eva, Mathilde Besson, Marie-Helene Brice, Laura Burkle, Giulio V. Dalla Riva, Marie-Jos\u00e9e Fortin, Dominique Gravel, et al. \u201cAnalyzing Ecological Networks of Species Interactions.\u201d BioRxiv, (2017), 112540. https://doi.org/10.1101/112540.  We highly recommend we keep it nearby when using the package. A lot of decisions taken during development are grounded in the analysis of the literature we conducted over a few years.", 
            "title": "References"
        }, 
        {
            "location": "/#network-diversity", 
            "text": "The analysis of network dissimilarity is done exactly as described in:  Poisot, Timoth\u00e9e, Elsa Canard, David Mouillot, Nicolas Mouquet, and Dominique Gravel. \u201cThe Dissimilarity of Species Interaction Networks.\u201d Ecology Letters 15, no. 12 (2012): 1353\u20131361. https://doi.org/10.1111/ele.12002.  The measures for \u03b2-diversity (and the approach of partitioning variation in sets) is done exactly as described in:  Koleff, Patricia, Kevin J. Gaston, and Jack J. Lennon. \u201cMeasuring Beta Diversity for Presence\u2013absence Data.\u201d Journal of Animal Ecology 72, no. 3 (2003): 367\u201382. https://doi.org/10.1046/j.1365-2656.2003.00710.x.  The functions presented in their table are implemented as  KGLXX , where  XX  is the number of the function on two digits ( i.e.  the second measure of \u03b2-diversity is  KGL02 ).", 
            "title": "Network \u03b2-diversity"
        }, 
        {
            "location": "/#specificity", 
            "text": "Poisot, Timothee, Elsa Canard, Nicolas Mouquet, and Michael E Hochberg. \u201cA Comparative Study of Ecological Specialization Estimators.\u201d Methods in Ecology and Evolution 3, no. 3 (2012): 537\u201344. https://doi.org/10.1111/j.2041-210X.2011.00174.x.", 
            "title": "Specificity"
        }, 
        {
            "location": "/#probabilistic-networks", 
            "text": "Poisot, Timoth\u00e9e, Alyssa R. Cirtwill, K\u00e9vin Cazelles, Dominique Gravel, Marie-Jos\u00e9e Fortin, and Daniel B. Stouffer. \u201cThe Structure of Probabilistic Networks.\u201d Methods in Ecology and Evolution 7, no. 3 (2016): 303\u201312. https://doi.org/10.1111/2041-210X.12468.", 
            "title": "Probabilistic networks"
        }, 
        {
            "location": "/#how-can-i-contribute", 
            "text": "Good question!  The easiest way to contribute is to use the package, and  open an issue  whenever you can't manage to do something, think the syntax is not clear, or the documentation is confusing. This is seriously one of the best ways to help.  If you want to contribute code, you can fork this repository, and start adding the functions you want, or changing the code. Please work from the  develop  branch ( master  does not accept pull requests except from maintainers, and cannot be pushed to unless a series of conditions are met). It's better if all of your code is tested and documented, but we will work with you when receiving the pull request anyways.", 
            "title": "How can I contribute?"
        }, 
        {
            "location": "/toc/", 
            "text": "Table of contents\n\n\n\n\nEcologicalNetwork\n\n\nPackage philosophy\n\n\nWhy should I use this package?\n\n\nBut it doesn't even make figures!\n\n\nAnd it doesn't even generate random networks!\n\n\nAnd worse, you forgot my favorite method!\n\n\n\n\n\n\nReferences\n\n\nNetwork \u03b2-diversity\n\n\nSpecificity\n\n\nProbabilistic networks\n\n\n\n\n\n\nHow can I contribute?\n\n\n\n\n\n\n\n\n\n\nInterface\n\n\n\n\nTypes of networks\n\n\nNetwork representation\n\n\nPartiteness\n\n\nType of information\n\n\n\n\n\n\nUnion types\n\n\nBy partiteness\n\n\nBy interaction type\n\n\n\n\n\n\nList of available types\n\n\n\n\n\n\nConversions\n\n\nCore functions\n\n\nAccessing species\n\n\nAccessing interactions\n\n\nPresence of an interaction\n\n\nNetwork slices\n\n\nRandom network samples\n\n\n\n\n\n\nNetwork utilities\n\n\nNetwork size\n\n\nSpecies richness\n\n\nChanging network shape\n\n\nInvert interactions\n\n\nModify interactions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProperties\n\n\n\n\nLinks, degree, connectance\n\n\nConnectance and number of links\n\n\nDegree\n\n\nSpecies without interactions\n\n\nSpecies-level specificity\n\n\n\n\n\n\nModularity\n\n\nExample\n\n\nMeasures\n\n\nStarters\n\n\nOptimizers\n\n\n\n\n\n\nNestedness\n\n\nMotif enumeration\n\n\nExample\n\n\nList of canonical motifs\n\n\nMotif counting\n\n\nProbabilistic case\n\n\n\n\n\n\nPaths and centrality\n\n\nNumber of paths and shortest path\n\n\nCentrality measures\n\n\n\n\n\n\nRandomization of networks\n\n\nDraw a network from a probabilistic network\n\n\nGenerate probabilistic networks from deterministic networks\n\n\nShuffle interactions\n\n\n\n\n\n\nNetwork \u03b2-diversity\n\n\n\u03b2-diversity components\n\n\n\u03b2-diversity measures\n\n\nBasic operations on networks", 
            "title": "Table of contents"
        }, 
        {
            "location": "/toc/#table-of-contents", 
            "text": "EcologicalNetwork  Package philosophy  Why should I use this package?  But it doesn't even make figures!  And it doesn't even generate random networks!  And worse, you forgot my favorite method!    References  Network \u03b2-diversity  Specificity  Probabilistic networks    How can I contribute?", 
            "title": "Table of contents"
        }, 
        {
            "location": "/toc/#interface", 
            "text": "Types of networks  Network representation  Partiteness  Type of information    Union types  By partiteness  By interaction type    List of available types    Conversions  Core functions  Accessing species  Accessing interactions  Presence of an interaction  Network slices  Random network samples    Network utilities  Network size  Species richness  Changing network shape  Invert interactions  Modify interactions", 
            "title": "Interface"
        }, 
        {
            "location": "/toc/#properties", 
            "text": "Links, degree, connectance  Connectance and number of links  Degree  Species without interactions  Species-level specificity    Modularity  Example  Measures  Starters  Optimizers    Nestedness  Motif enumeration  Example  List of canonical motifs  Motif counting  Probabilistic case    Paths and centrality  Number of paths and shortest path  Centrality measures    Randomization of networks  Draw a network from a probabilistic network  Generate probabilistic networks from deterministic networks  Shuffle interactions    Network \u03b2-diversity  \u03b2-diversity components  \u03b2-diversity measures  Basic operations on networks", 
            "title": "Properties"
        }, 
        {
            "location": "/interface/types/", 
            "text": "Types of networks\n\n\nOne feature of \nEcologicalNetwork\n which makes the rest of the package works is the type system to represent networks. This is not the most enthralling reading, but this pacge will walk you through the different options, and discuss how and when to use them.\n\n\n\n\nNetwork representation\n\n\nAll networks types have a field \nA\n to store the adjacency matrix, and fields \nS\n, or \nT\n and \nB\n, for species in unipartite and bipartite networks respectively. \nA\n is always a two-dimensional array (see below for more information), where interactions go \nfrom the rows\n, \nto the columns\n. Network types are \nmutable\n. Operations that will modify the network end with a \n!\n, as is the julian convention.\n\n\nFields \nS\n, \nT\n, and \nB\n are one-dimensional arrays of \nAllowedSpeciesTypes\n \u2013 they currently can be \nString\n or \nSymbol\n, and represent the species/nodes names. Future allowed types will be added in later releases.\n\n\nYou should \nnever\n have to manipulate the network by calling its fields directly. The \nspecies\n function will give you access to the species, and the network slicing operations (see later sections) will let you access subset of the network / individual interactions / set of neighbours.\n\n\nNetwork types are currently \nnot iterable\n, but this may be built into a next release.\n\n\n\n\nPartiteness\n\n\nIn unipartite networks, the adjancency matrix \nA\n is square, and has as many rows/columns as there are elements in \nS\n. This is always checked and enforced upon construction of the object, so you \ncannot\n have a mismatch.\n\n\nIn bipartite networks, the matrix \nA\n is not necessarily square, and has dimensions equal to the lengths of \nT\n (rows) and \nB\n (columns). This too is checked upon construction.\n\n\nAll elements in \nS\n \nmust\n be unique (no duplicate node names). In addition, all names in the union of \nT\n and \nB\n must be unique too (so that when a bipartite network is cast to a unipartite one, the constraint on unique names in \nS\n is respected).\n\n\n\n\nType of information\n\n\nAt all points, you can have a look at the types of the interactions and the species objects \u2013 the next entries in this documentation give additional information about the types allowed.\n\n\n#\n\n\nBase.eltype\n \n \nFunction\n.\n\n\neltype(N::T) where T\n:AbstractEcologicalNetwork\n\n\n\n\nReturns a tuple with two types: the type of the interactions, and the type of the species objects.\n\n\nsource\n\n\n\n\nUnion types\n\n\nAll networks are grouped upon the \nAbstractEcologicalNetwork\n type:\n\n\n#\n\n\nEcologicalNetwork.AbstractEcologicalNetwork\n \n \nType\n.\n\n\nAll networks in the package belong to the \nAbstractEcologicalNetwork\n type. They all have a field \nA\n to represent interactions as a \nmatrix\n, and a number of fields for species. See the documentation for \nAbstractBipartiteNetwork\n and \nAbstractUnipartiteNetwork\n, as well as \nAllowedSpeciesTypes\n for the allowed types for species.\n\n\nNote that \nall\n species in a network (including both levels of a bipartite network) \nmust\n have the same type. For example, \n[\"a\", :b, \"c\"]\n is not a valid array of species, as not all its elements have the same type.\n\n\nsource\n\n\nAll allowed types for nodes are part of the \nAllowedSpeciesTypes\n type:\n\n\n#\n\n\nEcologicalNetwork.AllowedSpeciesTypes\n \n \nConstant\n.\n\n\nThe \nAllowedSpeciesTypes\n union is used to restrict the type of objects that can be used to identify the species in a network. Currently, this is limited to \nSymbol\n and \nString\n. Numeric types (esp. integers) will \nnever\n be allowed, because they are used for positional access of species and interactions. As the ecosystem of packages for ecology matures, more types will be added to this union.\n\n\nsource\n\n\n\n\nBy partiteness\n\n\n#\n\n\nEcologicalNetwork.AbstractBipartiteNetwork\n \n \nType\n.\n\n\nThis abstract type groups all bipartite networks, regardless of the type of information. Bipartite networks have \ntwo\n fields for species, named \nT\n (for top, corresponding to matrix \nrows\n), and \nB\n (for bottom, matrix \ncolumns\n).\n\n\nAny bipartite network can be declared (we'll use the example of a binary network) either using \nBipartiteNetwork(A, T, B)\n (assuming \nA\n is a matrix of interactions and \nT\n and \nB\n are vectors of species names for the top and bottom level), or \nBipartiteNetwork(A)\n, in which case the species will be named automatically.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.AbstractUnipartiteNetwork\n \n \nType\n.\n\n\nThis abstract type groups all unipartite networks, regardless of the type of information. Unipartite networks have \na single\n field for species, named \nS\n, which has the same number of elements as the size of the matrix.\n\n\nAny unipartite network can be declared (we'll use the example of a binary network) either using \nUnipartiteNetwork(A, S)\n (assuming \nA\n is a matrix of interactions and \nS\n is a vector of species names), or \nUnipartiteNetwork(A)\n, in which case the species will be named automatically.\n\n\nsource\n\n\n\n\nBy interaction type\n\n\n#\n\n\nEcologicalNetwork.BinaryNetwork\n \n \nConstant\n.\n\n\nThis is a union type for both Bipartite and Unipartite deterministic networks. All networks from these class have adjacency matrices represented as arrays of Boolean values.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.QuantitativeNetwork\n \n \nConstant\n.\n\n\nThis is a union type for both unipartite and bipartite quantitative networks. All networks of this type have adjancency matrices as two-dimensional arrays of numbers.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.ProbabilisticNetwork\n \n \nConstant\n.\n\n\nThis is a union type for both Bipartite and Unipartite probabilistic networks. Probabilistic networks are represented as arrays of floating point values \u2208 [0;1].\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.DeterministicNetwork\n \n \nConstant\n.\n\n\nAll non-probabilistic networks\n\n\nsource\n\n\n\n\nList of available types\n\n\nThese are the types that you \nactually\n declare and use. They are presented last because it is easier to understand what they are when you get a sense for the different union types.\n\n\n#\n\n\nEcologicalNetwork.UnipartiteNetwork\n \n \nType\n.\n\n\nAn unipartite deterministic network is a matrix of boolean values.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.BipartiteNetwork\n \n \nType\n.\n\n\nA bipartite deterministic network is a matrix of boolean values.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.UnipartiteQuantitativeNetwork\n \n \nType\n.\n\n\nA unipartite quantitative network is a square matrix of numbers.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.BipartiteQuantitativeNetwork\n \n \nType\n.\n\n\nA bipartite quantitative network is matrix of numbers. It is assumed that the interaction strength are \npositive\n.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.UnipartiteProbabilisticNetwork\n \n \nType\n.\n\n\nA unipartite probabilistic network is a square matrix of floating point numbers, all of which must be between 0 and 1.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.BipartiteProbabilisticNetwork\n \n \nType\n.\n\n\nA bipartite probabilistic network is a matrix of floating point numbers, all of which must be between 0 and 1.\n\n\nsource", 
            "title": "Types"
        }, 
        {
            "location": "/interface/types/#types-of-networks", 
            "text": "One feature of  EcologicalNetwork  which makes the rest of the package works is the type system to represent networks. This is not the most enthralling reading, but this pacge will walk you through the different options, and discuss how and when to use them.", 
            "title": "Types of networks"
        }, 
        {
            "location": "/interface/types/#network-representation", 
            "text": "All networks types have a field  A  to store the adjacency matrix, and fields  S , or  T  and  B , for species in unipartite and bipartite networks respectively.  A  is always a two-dimensional array (see below for more information), where interactions go  from the rows ,  to the columns . Network types are  mutable . Operations that will modify the network end with a  ! , as is the julian convention.  Fields  S ,  T , and  B  are one-dimensional arrays of  AllowedSpeciesTypes  \u2013 they currently can be  String  or  Symbol , and represent the species/nodes names. Future allowed types will be added in later releases.  You should  never  have to manipulate the network by calling its fields directly. The  species  function will give you access to the species, and the network slicing operations (see later sections) will let you access subset of the network / individual interactions / set of neighbours.  Network types are currently  not iterable , but this may be built into a next release.", 
            "title": "Network representation"
        }, 
        {
            "location": "/interface/types/#partiteness", 
            "text": "In unipartite networks, the adjancency matrix  A  is square, and has as many rows/columns as there are elements in  S . This is always checked and enforced upon construction of the object, so you  cannot  have a mismatch.  In bipartite networks, the matrix  A  is not necessarily square, and has dimensions equal to the lengths of  T  (rows) and  B  (columns). This too is checked upon construction.  All elements in  S   must  be unique (no duplicate node names). In addition, all names in the union of  T  and  B  must be unique too (so that when a bipartite network is cast to a unipartite one, the constraint on unique names in  S  is respected).", 
            "title": "Partiteness"
        }, 
        {
            "location": "/interface/types/#type-of-information", 
            "text": "At all points, you can have a look at the types of the interactions and the species objects \u2013 the next entries in this documentation give additional information about the types allowed.  #  Base.eltype     Function .  eltype(N::T) where T :AbstractEcologicalNetwork  Returns a tuple with two types: the type of the interactions, and the type of the species objects.  source", 
            "title": "Type of information"
        }, 
        {
            "location": "/interface/types/#union-types", 
            "text": "All networks are grouped upon the  AbstractEcologicalNetwork  type:  #  EcologicalNetwork.AbstractEcologicalNetwork     Type .  All networks in the package belong to the  AbstractEcologicalNetwork  type. They all have a field  A  to represent interactions as a  matrix , and a number of fields for species. See the documentation for  AbstractBipartiteNetwork  and  AbstractUnipartiteNetwork , as well as  AllowedSpeciesTypes  for the allowed types for species.  Note that  all  species in a network (including both levels of a bipartite network)  must  have the same type. For example,  [\"a\", :b, \"c\"]  is not a valid array of species, as not all its elements have the same type.  source  All allowed types for nodes are part of the  AllowedSpeciesTypes  type:  #  EcologicalNetwork.AllowedSpeciesTypes     Constant .  The  AllowedSpeciesTypes  union is used to restrict the type of objects that can be used to identify the species in a network. Currently, this is limited to  Symbol  and  String . Numeric types (esp. integers) will  never  be allowed, because they are used for positional access of species and interactions. As the ecosystem of packages for ecology matures, more types will be added to this union.  source", 
            "title": "Union types"
        }, 
        {
            "location": "/interface/types/#by-partiteness", 
            "text": "#  EcologicalNetwork.AbstractBipartiteNetwork     Type .  This abstract type groups all bipartite networks, regardless of the type of information. Bipartite networks have  two  fields for species, named  T  (for top, corresponding to matrix  rows ), and  B  (for bottom, matrix  columns ).  Any bipartite network can be declared (we'll use the example of a binary network) either using  BipartiteNetwork(A, T, B)  (assuming  A  is a matrix of interactions and  T  and  B  are vectors of species names for the top and bottom level), or  BipartiteNetwork(A) , in which case the species will be named automatically.  source  #  EcologicalNetwork.AbstractUnipartiteNetwork     Type .  This abstract type groups all unipartite networks, regardless of the type of information. Unipartite networks have  a single  field for species, named  S , which has the same number of elements as the size of the matrix.  Any unipartite network can be declared (we'll use the example of a binary network) either using  UnipartiteNetwork(A, S)  (assuming  A  is a matrix of interactions and  S  is a vector of species names), or  UnipartiteNetwork(A) , in which case the species will be named automatically.  source", 
            "title": "By partiteness"
        }, 
        {
            "location": "/interface/types/#by-interaction-type", 
            "text": "#  EcologicalNetwork.BinaryNetwork     Constant .  This is a union type for both Bipartite and Unipartite deterministic networks. All networks from these class have adjacency matrices represented as arrays of Boolean values.  source  #  EcologicalNetwork.QuantitativeNetwork     Constant .  This is a union type for both unipartite and bipartite quantitative networks. All networks of this type have adjancency matrices as two-dimensional arrays of numbers.  source  #  EcologicalNetwork.ProbabilisticNetwork     Constant .  This is a union type for both Bipartite and Unipartite probabilistic networks. Probabilistic networks are represented as arrays of floating point values \u2208 [0;1].  source  #  EcologicalNetwork.DeterministicNetwork     Constant .  All non-probabilistic networks  source", 
            "title": "By interaction type"
        }, 
        {
            "location": "/interface/types/#list-of-available-types", 
            "text": "These are the types that you  actually  declare and use. They are presented last because it is easier to understand what they are when you get a sense for the different union types.  #  EcologicalNetwork.UnipartiteNetwork     Type .  An unipartite deterministic network is a matrix of boolean values.  source  #  EcologicalNetwork.BipartiteNetwork     Type .  A bipartite deterministic network is a matrix of boolean values.  source  #  EcologicalNetwork.UnipartiteQuantitativeNetwork     Type .  A unipartite quantitative network is a square matrix of numbers.  source  #  EcologicalNetwork.BipartiteQuantitativeNetwork     Type .  A bipartite quantitative network is matrix of numbers. It is assumed that the interaction strength are  positive .  source  #  EcologicalNetwork.UnipartiteProbabilisticNetwork     Type .  A unipartite probabilistic network is a square matrix of floating point numbers, all of which must be between 0 and 1.  source  #  EcologicalNetwork.BipartiteProbabilisticNetwork     Type .  A bipartite probabilistic network is a matrix of floating point numbers, all of which must be between 0 and 1.  source", 
            "title": "List of available types"
        }, 
        {
            "location": "/interface/conversions/", 
            "text": "Conversions\n\n\nConversions between types are used to perform two usual operations: make a bipartite network unipartite, and remove quantitative information. There are two high-level functions which work by using the union types, and a series of type-to-type functions (the later should be avoided, and exists only to make the high-level functions work).\n\n\n#\n\n\nBase.convert\n \n \nFunction\n.\n\n\nconvert(::Type{UnipartiteNetwork}, N::T) where {T \n: BipartiteNetwork}\n\n\n\n\nProjects a deterministic bipartite network in its unipartite representation.\n\n\nsource\n\n\nconvert(::Type{UnipartiteProbabilisticNetwork}, N::T) where {T \n: BipartiteProbabilisticNetwork}\n\n\n\n\nProjects a probabilistic bipartite network in its unipartite representation.\n\n\nsource\n\n\nconvert(::Type{UnipartiteQuantitativeNetwork}, N::T) where {T \n: BipartiteQuantitativeNetwork}\n\n\n\n\nProjects a quantitative bipartite network in its unipartite representation.\n\n\nsource\n\n\nconvert(::Type{UnipartiteNetwork}, N::T) where {T \n: UnipartiteQuantitativeNetwork}\n\n\n\n\nConvert a unipartite quantitative network to a unipartite binary network. This amounts to \nremoving\n the quantitative information.\n\n\nsource\n\n\nconvert(::Type{BipartiteNetwork}, N::T) where {T \n: BipartiteQuantitativeNetwork}\n\n\n\n\nConvert a bipartite quantitative network to a bipartite binary network. This amounts to \nremoving\n the quantitative information.\n\n\nsource\n\n\nconvert(::Type{AbstractUnipartiteNetwork}, N::AbstractBipartiteNetwork)\n\n\n\n\nProjects any bipartite network in its unipartite representation. This function will call the correct type-to-type \nconvert\n function depending on the type of the input network.\n\n\nThe type to be converted to \nmust\n be \nAbstractUnipartiteNetwork\n \u2013 for example, converting a bipartite probabilistic network to a probabilistic unipartite network is not a meaningful operation.\n\n\nsource\n\n\nconvert(::Type{BinaryNetwork}, N::QuantitativeNetwork)\n\n\n\n\nProjects any bipartite network in its unipartite representation. This function will call the correct type-to-type \nconvert\n function depending on the type of the input network.\n\n\nThis function does \nnot\n work for probabilistic networks. The operation of generating a deterministic network from a probabilistic one is different from a simple conversion: it can be done either through random draws, or by selecting only interactions with a probability greater than 0 (\nN\n0.0\n will do this).\n\n\nsource", 
            "title": "Type conversions"
        }, 
        {
            "location": "/interface/conversions/#conversions", 
            "text": "Conversions between types are used to perform two usual operations: make a bipartite network unipartite, and remove quantitative information. There are two high-level functions which work by using the union types, and a series of type-to-type functions (the later should be avoided, and exists only to make the high-level functions work).  #  Base.convert     Function .  convert(::Type{UnipartiteNetwork}, N::T) where {T  : BipartiteNetwork}  Projects a deterministic bipartite network in its unipartite representation.  source  convert(::Type{UnipartiteProbabilisticNetwork}, N::T) where {T  : BipartiteProbabilisticNetwork}  Projects a probabilistic bipartite network in its unipartite representation.  source  convert(::Type{UnipartiteQuantitativeNetwork}, N::T) where {T  : BipartiteQuantitativeNetwork}  Projects a quantitative bipartite network in its unipartite representation.  source  convert(::Type{UnipartiteNetwork}, N::T) where {T  : UnipartiteQuantitativeNetwork}  Convert a unipartite quantitative network to a unipartite binary network. This amounts to  removing  the quantitative information.  source  convert(::Type{BipartiteNetwork}, N::T) where {T  : BipartiteQuantitativeNetwork}  Convert a bipartite quantitative network to a bipartite binary network. This amounts to  removing  the quantitative information.  source  convert(::Type{AbstractUnipartiteNetwork}, N::AbstractBipartiteNetwork)  Projects any bipartite network in its unipartite representation. This function will call the correct type-to-type  convert  function depending on the type of the input network.  The type to be converted to  must  be  AbstractUnipartiteNetwork  \u2013 for example, converting a bipartite probabilistic network to a probabilistic unipartite network is not a meaningful operation.  source  convert(::Type{BinaryNetwork}, N::QuantitativeNetwork)  Projects any bipartite network in its unipartite representation. This function will call the correct type-to-type  convert  function depending on the type of the input network.  This function does  not  work for probabilistic networks. The operation of generating a deterministic network from a probabilistic one is different from a simple conversion: it can be done either through random draws, or by selecting only interactions with a probability greater than 0 ( N 0.0  will do this).  source", 
            "title": "Conversions"
        }, 
        {
            "location": "/interface/highlevel/", 
            "text": "Core functions\n\n\nThis page presents the core functions to manipulate networks. Whenever possible, the approach of \nEcologicalNetwork\n is to overload functions from \nBase\n.\n\n\n\n\nAccessing species\n\n\n#\n\n\nEcologicalNetwork.species\n \n \nFunction\n.\n\n\nspecies(N::AbstractUnipartiteNetwork)\n\n\n\n\nReturns an array of all species in a unipartite network. The order of the species corresponds to the order of rows/columns in the adjacency matrix.\n\n\nsource\n\n\nspecies(N::AbstractBipartiteNetwork)\n\n\n\n\nReturns an array of all species in a bipartite network. The order of the species corresponds to the order of rows (top level) and columns (bottom level) of the adjacency matrix, in this order.\n\n\nsource\n\n\nspecies(N::AbstractBipartiteNetwork, i::Int64)\n\n\n\n\nReturns an array of species in either side of a bipartite network. The \ni\n parameter is the \"margin\" of the network, where \n1\n is species from the top, and \n2\n is species from the bottom layer.\n\n\nsource\n\n\nspecies(N::AbstractUnipartiteNetwork, i::Int64)\n\n\n\n\nReturns an array of species on either side of a unipartite network. In a unipartite network, species are the same on either size, so this essentially calls \nspecies(N)\n. This function is nevertheless useful when you want to write code that takes either side of the network in a general way.\n\n\nsource\n\n\n\n\nAccessing interactions\n\n\n\n\nPresence of an interaction\n\n\n#\n\n\nEcologicalNetwork.has_interaction\n \n \nFunction\n.\n\n\nhas_interaction(N::AbstractEcologicalNetwork, i::Int64, j::Int64)\n\n\n\n\nThis function returns \ntrue\n if the interaction between \ni\n and \nj\n is not 0. This refers to species by their position instead of their name, and is not recommended as the main solution. This is used internally by a few functions, but is exported because it may be of general use.\n\n\nsource\n\n\nhas_interaction{NT\n:AllowedSpeciesTypes}(N::AbstractEcologicalNetwork, i::NT, j::NT)\n\n\n\n\nThis function returns \ntrue\n if the interaction between \ni\n and \nj\n is not 0. This refers to species by their names/values, and is the recommended way to test for the presence of an interaction.\n\n\nUse \nN[i,j]\n if you need to get the value of the interaction.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.interactions\n \n \nFunction\n.\n\n\ninteractions(N::AbstractEcologicalNetwork)\n\n\n\n\nReturns the interactions in the ecological network. Interactions are returned as an array of named tuples. \nA minima\n, these have fields \nfrom\n and \nto\n. For networks that are probabilistic, there is a \nprobability\n field. For networks that are quantitative, there is a \nstrength\n field. This functions allows to iterate over interactions in a network in a convenient way.\n\n\nsource\n\n\n\n\nNetwork slices\n\n\n#\n\n\nBase.getindex\n \n \nFunction\n.\n\n\ngetindex(N::AbstractEcologicalNetwork, i...)\n\n\n\n\nUses positions to get an index from a network position. It is recommended \nnot\n to use this function, and instead use the variants of \ngetindex\n working with species names directly.\n\n\nsource\n\n\ngetindex{T\n:AllowedSpeciesTypes}(N::AbstractEcologicalNetwork, s1::T, s2::T)\n\n\n\n\nGet the value of an interaction based on the \nname\n of the species. This is the recommended way to look for things in a network.\n\n\nsource\n\n\ngetindex{T\n:AllowedSpeciesTypes}(N::AbstractBipartiteNetwork, ::Colon, sp::T)\n\n\n\n\nGets the predecessors (\ni.e.\n species that interacts with / consume) of a focal species. This returns the list of species as a \nSet\n object, in which ordering is unimportant.\n\n\nsource\n\n\ngetindex{T\n:AllowedSpeciesTypes}(N::AbstractEcologicalNetwork, sp::T, ::Colon)\n\n\n\n\nGets the successors (\ni.e.\n species that are interacted with / consumed) of a focal species. This returns the list of species as a \nSet\n object, in which ordering is unimportant.\n\n\nsource\n\n\ngetindex{T\n:AllowedSpeciesTypes}(N::AbstractUnipartiteNetwork, sp::Array{T})\n\n\n\n\nInduce a unipartite network based on a list of species, all of which must be in the original network. This function takes a single argument (as opposed to two arrays, or an array and a colon) to ensure that the returned network is unipartite.\n\n\nThe network which is returned by this function may not have the species in the order specified by the user for performance reasons.\n\n\nsource\n\n\ngetindex{T\n:AllowedSpeciesTypes}(N::AbstractBipartiteNetwork, ::Colon, sp::Array{T})\n\n\n\n\nTODO\n\n\nsource\n\n\ngetindex{T\n:AllowedSpeciesTypes}(N::AbstractBipartiteNetwork, sp::Array{T}, ::Colon)\n\n\n\n\nTODO\n\n\nsource\n\n\ngetindex{T\n:AllowedSpeciesTypes}(N::AbstractBipartiteNetwork, sp1::Array{T}, sp2::Array{T})\n\n\n\n\nTODO\n\n\nsource\n\n\n\n\nRandom network samples\n\n\n#\n\n\nStatsBase.sample\n \n \nFunction\n.\n\n\nsample(N::T, n::Int64) where {T\n:AbstractUnipartiteNetwork}\n\n\n\n\nSamples a sub-network from a unipartite network. \nn\n is the number of species to have in the sampled network. This functions makes \nno\n attempt to ensure that the network is not degenerate, or even has a single interaction. This is the recommended way to sample a unipartite network.\n\n\nsource\n\n\nsample(N::T, n::Tuple{Int64}) where {T\n:AbstractUnipartiteNetwork}\n\n\n\n\nSame as \nsample\n, but work when called with \n(n,)\n instead of a species number. This is an accepted way to sample a unipartite network.\n\n\nsource\n\n\nsample(N::T, n::Tuple{Int64,Int64}) where {T\n:AbstractUnipartiteNetwork}\n\n\n\n\nSame as \nsample\n but called with \n(n,n)\n instead of a species number. Note that this will fail if the size requested is not square. This is not a really good way to sample a unipartite network.\n\n\nsource\n\n\nsample(N::T, n::Tuple{Int64}) where {T\n:AbstractBipartiteNetwork}\n\n\n\n\nSame as \nsample\n but with a single species number given as \n(n,)\n, to return a bipartite network of equal richness on both sides. This is not a very good way to sample a bipartite network.\n\n\nsource\n\n\nsample(N::T, n::Int64) where {T\n:AbstractBipartiteNetwork}\n\n\n\n\nSame thing as \nsample\n but with a single species number, to return a bipartite network of equal richness on both sides. This is not a very good way to sample a bipartite network.\n\n\nsource\n\n\nsample(N::T, n::Tuple{Int64,Int64}) where {T\n:AbstractBipartiteNetwork}\n\n\n\n\nSamples a sub-network from a bipartite network. \nn\n is the size of the network to return, \ni.e.\n number of top and bottom species. This functions makes \nno\n attempt to ensure that the network is not degenerate, or even has a single interaction.\n\n\nThis is the recommended way to sample a bipartite network.\n\n\nsource\n\n\n\n\nNetwork utilities\n\n\n\n\nNetwork size\n\n\n#\n\n\nBase.size\n \n \nFunction\n.\n\n\nsize(N::AbstractEcologicalNetwork)\n\n\n\n\nReturn the size of the adjacency matrix of an \nAbstractEcologicalNetwork\n object.\n\n\nsource\n\n\n\n\nSpecies richness\n\n\n#\n\n\nEcologicalNetwork.richness\n \n \nFunction\n.\n\n\nrichness(N::AbstractEcologicalNetwork)\n\n\n\n\nReturns the number of species in a network.\n\n\nsource\n\n\nrichness(N::AbstractEcologicalNetwork, i::Int64)\n\n\n\n\nReturns the number of species on either side of the network. The value of \ni\n can be \n1\n (top-level species) or \n2\n (bottom-level species), as in the \nspecies\n function.\n\n\nsource\n\n\n\n\nChanging network shape\n\n\n#\n\n\nBase.transpose\n \n \nFunction\n.\n\n\ntranspose(N::AbstractBipartiteNetwork)\n\n\n\n\nReturns a transposed copy of the network.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.nodiagonal\n \n \nFunction\n.\n\n\nnodiagonal(N::AbstractUnipartiteNetwork)\n\n\n\n\nReturns a copy of the network with its diagonal set to zero.\n\n\nsource\n\n\nnodiagonal(N::AbstractBipartiteNetwork)\n\n\n\n\nReturns a \ncopy\n of the network (because the diagonal of a bipartite network is never a meaningful notion). This function is clearly useless, but allows to write general code for all networks types when a step requires removing the diagonal.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.nodiagonal!\n \n \nFunction\n.\n\n\nnodiagonal!(N::AbstractUnipartiteNetwork)\n\n\n\n\nModifies the network so that its diagonal is set to the appropriate zero.\n\n\nsource\n\n\nnodiagonal!(N::AbstractBipartiteNetwork)\n\n\n\n\nDoes nothing.\n\n\nsource\n\n\n\n\nInvert interactions\n\n\n#\n\n\nBase.:!\n \n \nFunction\n.\n\n\nBase.:!{T\n:DeterministicNetwork}(N::T)\n\n\n\n\nReturns the inverse of a binary network \u2013 interactions that were \nfalse\n become \ntrue\n, and conversely.\n\n\nsource\n\n\n\n\nModify interactions\n\n\n#\n\n\nBase.setindex!\n \n \nFunction\n.\n\n\nsetindex!(N::T, A::Any, i::E, j::E) where {T \n: AbstractEcologicalNetwork, E \n: AllowedSpeciesTypes}\n\n\n\n\nChanges the value of the interaction at the specificied position, where \ni\n and \nj\n are species \nnames\n. Note that this operation \nchanges the network\n.\n\n\nsource\n\n\nsetindex!(N::T, A::K, i::E, j::E) where {T \n: AbstractEcologicalNetwork, K \n: first(eltype(N)), E \n: Int}\n\n\n\n\nChanges the value of the interaction at the specificied position, where \ni\n and \nj\n are species \npositions\n. Note that this operation \nchanges the network\n.\n\n\nsource", 
            "title": "Core functions"
        }, 
        {
            "location": "/interface/highlevel/#core-functions", 
            "text": "This page presents the core functions to manipulate networks. Whenever possible, the approach of  EcologicalNetwork  is to overload functions from  Base .", 
            "title": "Core functions"
        }, 
        {
            "location": "/interface/highlevel/#accessing-species", 
            "text": "#  EcologicalNetwork.species     Function .  species(N::AbstractUnipartiteNetwork)  Returns an array of all species in a unipartite network. The order of the species corresponds to the order of rows/columns in the adjacency matrix.  source  species(N::AbstractBipartiteNetwork)  Returns an array of all species in a bipartite network. The order of the species corresponds to the order of rows (top level) and columns (bottom level) of the adjacency matrix, in this order.  source  species(N::AbstractBipartiteNetwork, i::Int64)  Returns an array of species in either side of a bipartite network. The  i  parameter is the \"margin\" of the network, where  1  is species from the top, and  2  is species from the bottom layer.  source  species(N::AbstractUnipartiteNetwork, i::Int64)  Returns an array of species on either side of a unipartite network. In a unipartite network, species are the same on either size, so this essentially calls  species(N) . This function is nevertheless useful when you want to write code that takes either side of the network in a general way.  source", 
            "title": "Accessing species"
        }, 
        {
            "location": "/interface/highlevel/#accessing-interactions", 
            "text": "", 
            "title": "Accessing interactions"
        }, 
        {
            "location": "/interface/highlevel/#presence-of-an-interaction", 
            "text": "#  EcologicalNetwork.has_interaction     Function .  has_interaction(N::AbstractEcologicalNetwork, i::Int64, j::Int64)  This function returns  true  if the interaction between  i  and  j  is not 0. This refers to species by their position instead of their name, and is not recommended as the main solution. This is used internally by a few functions, but is exported because it may be of general use.  source  has_interaction{NT :AllowedSpeciesTypes}(N::AbstractEcologicalNetwork, i::NT, j::NT)  This function returns  true  if the interaction between  i  and  j  is not 0. This refers to species by their names/values, and is the recommended way to test for the presence of an interaction.  Use  N[i,j]  if you need to get the value of the interaction.  source  #  EcologicalNetwork.interactions     Function .  interactions(N::AbstractEcologicalNetwork)  Returns the interactions in the ecological network. Interactions are returned as an array of named tuples.  A minima , these have fields  from  and  to . For networks that are probabilistic, there is a  probability  field. For networks that are quantitative, there is a  strength  field. This functions allows to iterate over interactions in a network in a convenient way.  source", 
            "title": "Presence of an interaction"
        }, 
        {
            "location": "/interface/highlevel/#network-slices", 
            "text": "#  Base.getindex     Function .  getindex(N::AbstractEcologicalNetwork, i...)  Uses positions to get an index from a network position. It is recommended  not  to use this function, and instead use the variants of  getindex  working with species names directly.  source  getindex{T :AllowedSpeciesTypes}(N::AbstractEcologicalNetwork, s1::T, s2::T)  Get the value of an interaction based on the  name  of the species. This is the recommended way to look for things in a network.  source  getindex{T :AllowedSpeciesTypes}(N::AbstractBipartiteNetwork, ::Colon, sp::T)  Gets the predecessors ( i.e.  species that interacts with / consume) of a focal species. This returns the list of species as a  Set  object, in which ordering is unimportant.  source  getindex{T :AllowedSpeciesTypes}(N::AbstractEcologicalNetwork, sp::T, ::Colon)  Gets the successors ( i.e.  species that are interacted with / consumed) of a focal species. This returns the list of species as a  Set  object, in which ordering is unimportant.  source  getindex{T :AllowedSpeciesTypes}(N::AbstractUnipartiteNetwork, sp::Array{T})  Induce a unipartite network based on a list of species, all of which must be in the original network. This function takes a single argument (as opposed to two arrays, or an array and a colon) to ensure that the returned network is unipartite.  The network which is returned by this function may not have the species in the order specified by the user for performance reasons.  source  getindex{T :AllowedSpeciesTypes}(N::AbstractBipartiteNetwork, ::Colon, sp::Array{T})  TODO  source  getindex{T :AllowedSpeciesTypes}(N::AbstractBipartiteNetwork, sp::Array{T}, ::Colon)  TODO  source  getindex{T :AllowedSpeciesTypes}(N::AbstractBipartiteNetwork, sp1::Array{T}, sp2::Array{T})  TODO  source", 
            "title": "Network slices"
        }, 
        {
            "location": "/interface/highlevel/#random-network-samples", 
            "text": "#  StatsBase.sample     Function .  sample(N::T, n::Int64) where {T :AbstractUnipartiteNetwork}  Samples a sub-network from a unipartite network.  n  is the number of species to have in the sampled network. This functions makes  no  attempt to ensure that the network is not degenerate, or even has a single interaction. This is the recommended way to sample a unipartite network.  source  sample(N::T, n::Tuple{Int64}) where {T :AbstractUnipartiteNetwork}  Same as  sample , but work when called with  (n,)  instead of a species number. This is an accepted way to sample a unipartite network.  source  sample(N::T, n::Tuple{Int64,Int64}) where {T :AbstractUnipartiteNetwork}  Same as  sample  but called with  (n,n)  instead of a species number. Note that this will fail if the size requested is not square. This is not a really good way to sample a unipartite network.  source  sample(N::T, n::Tuple{Int64}) where {T :AbstractBipartiteNetwork}  Same as  sample  but with a single species number given as  (n,) , to return a bipartite network of equal richness on both sides. This is not a very good way to sample a bipartite network.  source  sample(N::T, n::Int64) where {T :AbstractBipartiteNetwork}  Same thing as  sample  but with a single species number, to return a bipartite network of equal richness on both sides. This is not a very good way to sample a bipartite network.  source  sample(N::T, n::Tuple{Int64,Int64}) where {T :AbstractBipartiteNetwork}  Samples a sub-network from a bipartite network.  n  is the size of the network to return,  i.e.  number of top and bottom species. This functions makes  no  attempt to ensure that the network is not degenerate, or even has a single interaction.  This is the recommended way to sample a bipartite network.  source", 
            "title": "Random network samples"
        }, 
        {
            "location": "/interface/highlevel/#network-utilities", 
            "text": "", 
            "title": "Network utilities"
        }, 
        {
            "location": "/interface/highlevel/#network-size", 
            "text": "#  Base.size     Function .  size(N::AbstractEcologicalNetwork)  Return the size of the adjacency matrix of an  AbstractEcologicalNetwork  object.  source", 
            "title": "Network size"
        }, 
        {
            "location": "/interface/highlevel/#species-richness", 
            "text": "#  EcologicalNetwork.richness     Function .  richness(N::AbstractEcologicalNetwork)  Returns the number of species in a network.  source  richness(N::AbstractEcologicalNetwork, i::Int64)  Returns the number of species on either side of the network. The value of  i  can be  1  (top-level species) or  2  (bottom-level species), as in the  species  function.  source", 
            "title": "Species richness"
        }, 
        {
            "location": "/interface/highlevel/#changing-network-shape", 
            "text": "#  Base.transpose     Function .  transpose(N::AbstractBipartiteNetwork)  Returns a transposed copy of the network.  source  #  EcologicalNetwork.nodiagonal     Function .  nodiagonal(N::AbstractUnipartiteNetwork)  Returns a copy of the network with its diagonal set to zero.  source  nodiagonal(N::AbstractBipartiteNetwork)  Returns a  copy  of the network (because the diagonal of a bipartite network is never a meaningful notion). This function is clearly useless, but allows to write general code for all networks types when a step requires removing the diagonal.  source  #  EcologicalNetwork.nodiagonal!     Function .  nodiagonal!(N::AbstractUnipartiteNetwork)  Modifies the network so that its diagonal is set to the appropriate zero.  source  nodiagonal!(N::AbstractBipartiteNetwork)  Does nothing.  source", 
            "title": "Changing network shape"
        }, 
        {
            "location": "/interface/highlevel/#invert-interactions", 
            "text": "#  Base.:!     Function .  Base.:!{T :DeterministicNetwork}(N::T)  Returns the inverse of a binary network \u2013 interactions that were  false  become  true , and conversely.  source", 
            "title": "Invert interactions"
        }, 
        {
            "location": "/interface/highlevel/#modify-interactions", 
            "text": "#  Base.setindex!     Function .  setindex!(N::T, A::Any, i::E, j::E) where {T  : AbstractEcologicalNetwork, E  : AllowedSpeciesTypes}  Changes the value of the interaction at the specificied position, where  i  and  j  are species  names . Note that this operation  changes the network .  source  setindex!(N::T, A::K, i::E, j::E) where {T  : AbstractEcologicalNetwork, K  : first(eltype(N)), E  : Int}  Changes the value of the interaction at the specificied position, where  i  and  j  are species  positions . Note that this operation  changes the network .  source", 
            "title": "Modify interactions"
        }, 
        {
            "location": "/properties/links/", 
            "text": "Links, degree, connectance\n\n\n\n\nConnectance and number of links\n\n\n#\n\n\nBase.sum\n \n \nFunction\n.\n\n\nsum(N::AbstractEcologicalNetwork)\n\n\n\n\nThis function will return the sum of all interactions in the network. For quantitative networks, this is the sum of interaction strengths. For binary networks, this is the number of interactions. For probabilistic networks, this is the expected number of realized interactions.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.links\n \n \nFunction\n.\n\n\nlinks(N::BinaryNetwork)\n\n\n\n\nNumber of non-zero interactions in a deterministic network.\n\n\nsource\n\n\nlinks(N::QuantitativeNetwork)\n\n\n\n\nNumber of non-zero interactions in a quantitative network (use \nsum\n to get the sum of interaction strengths).\n\n\nsource\n\n\nlinks(N::ProbabilisticNetwork)\n\n\n\n\nExpected number of interactions in a probabilistic network. To get the number of interactions that have a non-zero probability, use \ne.g.\n \nlinks(N\n0.0)\n.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.connectance\n \n \nFunction\n.\n\n\nconnectance(N::AbstractEcologicalNetwork)\n\n\n\n\nNumber of links divided by the number of possible interactions. In unipartite networks, this is $L/S^2$. In bipartite networks, this is $L/(T \u00d7 B)$. It is worth noting that while the maximal connectance is always 1 (i.e. the graph is complete), the minimum value (assuming that the network is not degenerate) is \nnot\n 0. Instead, the minimum number of interactions in a unipartite network is \nS-1\n, and in a bipartite network it is \nmax(T,B)\n.\n\n\nConnectance can therefore be transformed between 0 and 1, using the following approach: let \nm\n be the minimum number of interactions, and Co be the measured connectance, then the corrected value is \n(Co-m)/(1-m)\n. To our best knowledge, this is not standard practice, and therefore is not suggested as a function in the package.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.linkage_density\n \n \nFunction\n.\n\n\nlinkage_density(N::AbstractEcologicalNetwork)\n\n\n\n\nNumber of links divided by species richness.\n\n\nsource\n\n\n\n\nDegree\n\n\n#\n\n\nEcologicalNetwork.degree\n \n \nFunction\n.\n\n\nDegree of species in a unipartite network\n\n\ndegree(N::Unipartite)\n\n\n\n\nsource\n\n\nDegree of species in a bipartite network\n\n\ndegree(N::Bipartite)\n\n\n\n\nThis is a concatenation of the out degree and the in degrees of nodes on both sizes, as measured by making the graph unipartite first. Rows are first, columns second.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.degree_var\n \n \nFunction\n.\n\n\nVariance in the degree\n\n\ndegree_var(N::UnipartiteProbaNetwork)\n\n\n\n\nsource\n\n\n\n\nSpecies without interactions\n\n\n#\n\n\nEcologicalNetwork.isdegenerate\n \n \nFunction\n.\n\n\nisdegenerate(N::AbstractEcologicalNetwork)\n\n\n\n\nNetworks are called degenerate if some species have no interactions, either at all, or with any species other than themselves. This is particularly useful to decide the networks to keep when generating samples for null models.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.simplify!\n \n \nFunction\n.\n\n\nsimplify!{T\n:AbstractBipartiteNetwork}(N::T)\n\n\n\n\nReturns a new network in which species with no interactions have been removed.\n\n\nsource\n\n\nsimplify!(N::AbstractUnipartiteNetwork)\n\n\n\n\nModifies the network to drop all species without an interaction.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.simplify\n \n \nFunction\n.\n\n\nsimplify{T\n:AbstractBipartiteNetwork}(N::T)\n\n\n\n\nReturns a new network in which species with no interactions have been removed.\n\n\nsource\n\n\nsimplify(N::AbstractUnipartiteNetwork)\n\n\n\n\nReturns a new network in which species with no interactions have been removed.\n\n\nsource\n\n\n\n\nSpecies-level specificity\n\n\n#\n\n\nEcologicalNetwork.specificity\n \n \nFunction\n.\n\n\nResource range\n\n\nspecificity(N::DeterministicNetwork)\n\n\n\n\nMeasure of specificity in a deterministic network. This returns a value between 0 and 1, where 1 indicates maximal specificity.\n\n\n\n\nPoisot, T., Canard, E., Mouquet, N., Hochberg, M.E., 2012. A comparative study of ecological specialization estimators. Methods in Ecology and Evolution 3, 537\u2013544. doi:10.1111/j.2041-210X.2011.00174.x\n\n\n\n\nsource\n\n\nPaired Differences Index\n\n\nspecificity(N::QuantitativeNetwork)\n\n\n\n\nMeasure of specificity in a quantitative network. This returns a value between 0 and 1, where 1 indicates maximal specificity. Note that the PDI is measured species-wise, and the maximal interaction strength of every species is set to 1.\n\n\n\n\nPoisot, T., Canard, E., Mouquet, N., Hochberg, M.E., 2012. A comparative study of ecological specialization estimators. Methods in Ecology and Evolution 3, 537\u2013544. doi:10.1111/j.2041-210X.2011.00174.x\n\n\n\n\nsource", 
            "title": "Links"
        }, 
        {
            "location": "/properties/links/#links-degree-connectance", 
            "text": "", 
            "title": "Links, degree, connectance"
        }, 
        {
            "location": "/properties/links/#connectance-and-number-of-links", 
            "text": "#  Base.sum     Function .  sum(N::AbstractEcologicalNetwork)  This function will return the sum of all interactions in the network. For quantitative networks, this is the sum of interaction strengths. For binary networks, this is the number of interactions. For probabilistic networks, this is the expected number of realized interactions.  source  #  EcologicalNetwork.links     Function .  links(N::BinaryNetwork)  Number of non-zero interactions in a deterministic network.  source  links(N::QuantitativeNetwork)  Number of non-zero interactions in a quantitative network (use  sum  to get the sum of interaction strengths).  source  links(N::ProbabilisticNetwork)  Expected number of interactions in a probabilistic network. To get the number of interactions that have a non-zero probability, use  e.g.   links(N 0.0) .  source  #  EcologicalNetwork.connectance     Function .  connectance(N::AbstractEcologicalNetwork)  Number of links divided by the number of possible interactions. In unipartite networks, this is $L/S^2$. In bipartite networks, this is $L/(T \u00d7 B)$. It is worth noting that while the maximal connectance is always 1 (i.e. the graph is complete), the minimum value (assuming that the network is not degenerate) is  not  0. Instead, the minimum number of interactions in a unipartite network is  S-1 , and in a bipartite network it is  max(T,B) .  Connectance can therefore be transformed between 0 and 1, using the following approach: let  m  be the minimum number of interactions, and Co be the measured connectance, then the corrected value is  (Co-m)/(1-m) . To our best knowledge, this is not standard practice, and therefore is not suggested as a function in the package.  source  #  EcologicalNetwork.linkage_density     Function .  linkage_density(N::AbstractEcologicalNetwork)  Number of links divided by species richness.  source", 
            "title": "Connectance and number of links"
        }, 
        {
            "location": "/properties/links/#degree", 
            "text": "#  EcologicalNetwork.degree     Function .  Degree of species in a unipartite network  degree(N::Unipartite)  source  Degree of species in a bipartite network  degree(N::Bipartite)  This is a concatenation of the out degree and the in degrees of nodes on both sizes, as measured by making the graph unipartite first. Rows are first, columns second.  source  #  EcologicalNetwork.degree_var     Function .  Variance in the degree  degree_var(N::UnipartiteProbaNetwork)  source", 
            "title": "Degree"
        }, 
        {
            "location": "/properties/links/#species-without-interactions", 
            "text": "#  EcologicalNetwork.isdegenerate     Function .  isdegenerate(N::AbstractEcologicalNetwork)  Networks are called degenerate if some species have no interactions, either at all, or with any species other than themselves. This is particularly useful to decide the networks to keep when generating samples for null models.  source  #  EcologicalNetwork.simplify!     Function .  simplify!{T :AbstractBipartiteNetwork}(N::T)  Returns a new network in which species with no interactions have been removed.  source  simplify!(N::AbstractUnipartiteNetwork)  Modifies the network to drop all species without an interaction.  source  #  EcologicalNetwork.simplify     Function .  simplify{T :AbstractBipartiteNetwork}(N::T)  Returns a new network in which species with no interactions have been removed.  source  simplify(N::AbstractUnipartiteNetwork)  Returns a new network in which species with no interactions have been removed.  source", 
            "title": "Species without interactions"
        }, 
        {
            "location": "/properties/links/#species-level-specificity", 
            "text": "#  EcologicalNetwork.specificity     Function .  Resource range  specificity(N::DeterministicNetwork)  Measure of specificity in a deterministic network. This returns a value between 0 and 1, where 1 indicates maximal specificity.   Poisot, T., Canard, E., Mouquet, N., Hochberg, M.E., 2012. A comparative study of ecological specialization estimators. Methods in Ecology and Evolution 3, 537\u2013544. doi:10.1111/j.2041-210X.2011.00174.x   source  Paired Differences Index  specificity(N::QuantitativeNetwork)  Measure of specificity in a quantitative network. This returns a value between 0 and 1, where 1 indicates maximal specificity. Note that the PDI is measured species-wise, and the maximal interaction strength of every species is set to 1.   Poisot, T., Canard, E., Mouquet, N., Hochberg, M.E., 2012. A comparative study of ecological specialization estimators. Methods in Ecology and Evolution 3, 537\u2013544. doi:10.1111/j.2041-210X.2011.00174.x   source", 
            "title": "Species-level specificity"
        }, 
        {
            "location": "/properties/modularity/", 
            "text": "Modularity\n\n\nThe analysis of network modularity is done in three steps:\n\n\n\n\ngenerate a starting point, using one of the starter functions\n\n\noptimize modularity\n\n\nanalyse the output\n\n\n\n\nAll starter functions take a network as input, and return a tuple of this network and a dictionary where every species maps onto its module. This forms the input of all other modularity related functions.\n\n\n\n\nExample\n\n\nN = convert(BinaryNetwork, web_of_life(\nA_HP_001\n))\nN |\n lp |\n x -\n brim(x...) |\n x -\n Q(x...)\n\n\n\n\n0.208546089760817\n\n\n\n\n\n\nMeasures\n\n\nQ\nQr\n\n\n\n\n\n\nStarters\n\n\n#\n\n\nEcologicalNetwork.n_random_modules\n \n \nFunction\n.\n\n\nn_random_modules(n::Int64)\n\n\n\n\nThis returns \na function\n which, when applied to a network, will randomly assign every species to one of \nn\n modules. The correct way to apply this function to a network \nN\n is, therefore \nn_random_modules(4)(N)\n (with four modules).\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.each_species_its_module\n \n \nFunction\n.\n\n\neach_species_its_module(N::T) where {T\n:AbstractEcologicalNetwork}\n\n\n\n\nReturns a dictionary in which each species is its own module. This is used as a starting point for \nlp\n and \nsalp\n internally. This is often a very poor starting point for \nbrim\n, and should probably not be used on its own.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.lp\n \n \nFunction\n.\n\n\nlp(N::T) where {T\n:AbstractEcologicalNetwork}\n\n\n\n\nUses label propagation to generate a first approximation of the modular structure of a network. This is usually followed by the BRIM (\nbrim\n) method. This method supposedly performs better for large graphs, but we rarely observed any differences between it and variations of BRIM alone on smaller graphs.\n\n\nsource\n\n\n\n\nOptimizers\n\n\n#\n\n\nEcologicalNetwork.brim\n \n \nFunction\n.\n\n\nbrim(N::NT, L::Dict{E,Int64}) where {NT\n:AbstractEcologicalNetwork,E\n:AllowedSpeciesTypes}\n\n\n\n\nUses BRIM to optimize the modularity of an ecological network. The \nL\n argument is a dictionary mapping every species in the network to its module. This function returns a tuple of the network and its module assignment.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.salp\n \n \nFunction\n.\n\n\nsalp(N::T; \u03b8::Float64=1.0, steps::Int64=10_000, \u03bb::Float64=0.999, progress::Bool=false) where {T \n: BipartiteNetwork}\n\n\n\n\nLabel-propagation using simulated annealing. This function uses simulated annealing to propagate labels from neighboring nodes. It accepts a network as input. The schedule of the simulated annealing is linear: at step k+1, the temperature is \u03b8\u03bb\u1d4f. The initial temperature has been picked so that after 100 timesteps, using the default \u03bb, a move decreasing modularity by 0.05 (20% of the theoretical maximum) is picked with a probability of 0.1.\n\n\nOptional arguments regulating the behavior of the simulated annealing routine are:\n\n\n\n\n\u03bb=0.999\n, the rate of temperature decay\n\n\n\u03b8=0.002\n, the initial temperature\n\n\nsteps=10_000\n, the number of annealing steps to perform\n\n\nprogress=false\n, whether to display an info message every 100 timesteps\n\n\n\n\nThe \u03b8 parameter can be picked using the following method: if we want to allow a maximal loss of modularity of \u03b4, after timestep k, with a decay parameter \u03bb, with a probability P, then \u03b8 = -\u03b4/[\u03bb\u1d4f\u00d7ln(P)]\u207b\u00b9. By beibg more or less restrictive on these parameters, the user can pick a value of \u03b8 for every problem.\n\n\nThis function can work as a first step (like \nlp\n), but in explorations during the development of the package, we found that \nbrim\n was rarely (if ever) able to optmize the output further. It can therefore be used on its own.\n\n\nsource", 
            "title": "Modularity"
        }, 
        {
            "location": "/properties/modularity/#modularity", 
            "text": "The analysis of network modularity is done in three steps:   generate a starting point, using one of the starter functions  optimize modularity  analyse the output   All starter functions take a network as input, and return a tuple of this network and a dictionary where every species maps onto its module. This forms the input of all other modularity related functions.", 
            "title": "Modularity"
        }, 
        {
            "location": "/properties/modularity/#example", 
            "text": "N = convert(BinaryNetwork, web_of_life( A_HP_001 ))\nN |  lp |  x -  brim(x...) |  x -  Q(x...)  0.208546089760817", 
            "title": "Example"
        }, 
        {
            "location": "/properties/modularity/#measures", 
            "text": "Q\nQr", 
            "title": "Measures"
        }, 
        {
            "location": "/properties/modularity/#starters", 
            "text": "#  EcologicalNetwork.n_random_modules     Function .  n_random_modules(n::Int64)  This returns  a function  which, when applied to a network, will randomly assign every species to one of  n  modules. The correct way to apply this function to a network  N  is, therefore  n_random_modules(4)(N)  (with four modules).  source  #  EcologicalNetwork.each_species_its_module     Function .  each_species_its_module(N::T) where {T :AbstractEcologicalNetwork}  Returns a dictionary in which each species is its own module. This is used as a starting point for  lp  and  salp  internally. This is often a very poor starting point for  brim , and should probably not be used on its own.  source  #  EcologicalNetwork.lp     Function .  lp(N::T) where {T :AbstractEcologicalNetwork}  Uses label propagation to generate a first approximation of the modular structure of a network. This is usually followed by the BRIM ( brim ) method. This method supposedly performs better for large graphs, but we rarely observed any differences between it and variations of BRIM alone on smaller graphs.  source", 
            "title": "Starters"
        }, 
        {
            "location": "/properties/modularity/#optimizers", 
            "text": "#  EcologicalNetwork.brim     Function .  brim(N::NT, L::Dict{E,Int64}) where {NT :AbstractEcologicalNetwork,E :AllowedSpeciesTypes}  Uses BRIM to optimize the modularity of an ecological network. The  L  argument is a dictionary mapping every species in the network to its module. This function returns a tuple of the network and its module assignment.  source  #  EcologicalNetwork.salp     Function .  salp(N::T; \u03b8::Float64=1.0, steps::Int64=10_000, \u03bb::Float64=0.999, progress::Bool=false) where {T  : BipartiteNetwork}  Label-propagation using simulated annealing. This function uses simulated annealing to propagate labels from neighboring nodes. It accepts a network as input. The schedule of the simulated annealing is linear: at step k+1, the temperature is \u03b8\u03bb\u1d4f. The initial temperature has been picked so that after 100 timesteps, using the default \u03bb, a move decreasing modularity by 0.05 (20% of the theoretical maximum) is picked with a probability of 0.1.  Optional arguments regulating the behavior of the simulated annealing routine are:   \u03bb=0.999 , the rate of temperature decay  \u03b8=0.002 , the initial temperature  steps=10_000 , the number of annealing steps to perform  progress=false , whether to display an info message every 100 timesteps   The \u03b8 parameter can be picked using the following method: if we want to allow a maximal loss of modularity of \u03b4, after timestep k, with a decay parameter \u03bb, with a probability P, then \u03b8 = -\u03b4/[\u03bb\u1d4f\u00d7ln(P)]\u207b\u00b9. By beibg more or less restrictive on these parameters, the user can pick a value of \u03b8 for every problem.  This function can work as a first step (like  lp ), but in explorations during the development of the package, we found that  brim  was rarely (if ever) able to optmize the output further. It can therefore be used on its own.  source", 
            "title": "Optimizers"
        }, 
        {
            "location": "/properties/nestedness/", 
            "text": "Nestedness\n\n\n#\n\n\nEcologicalNetwork.\u03b7\n \n \nFunction\n.\n\n\n\u03b7(N::T) where {T \n: Union{BipartiteNetwork, BipartiteProbaNetwork}}\n\n\n\n\nThis returns the nestedness of the entire matrix.\n\n\nsource\n\n\n\u03b7(N::T, i::Int64) where {T \n: Union{BipartiteNetwork, BipartiteProbaNetwork}}\n\n\n\n\nReturns the nestedness of a margin of the network, using \u03b7. The second argument can be \n1\n (for nestedness of rows/top level) or \n2\n (for nestedness of columns/bottom level). This function will throw an \nArgumentError\n if you use an invalid value for \ni\n.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.nodf\n \n \nFunction\n.\n\n\nnodf(N::T) where {T \n: Union{BipartiteNetwork,BipartiteQuantitativeNetwork}}\n\n\n\n\nIf the network is quantitative, then \nWNODF\n is measured instead of \nNODF\n. Note that in \nall\n situations, the value goes between 0 (not nested) to 1 (perfectly nested). This is a change with regard to the original papers, in which the maximal value is 100. The nestedness for the entire network is returned.\n\n\nsource\n\n\nnodf(N::T, i::Int64) where {T \n: Union{BipartiteNetwork,BipartiteQuantitativeNetwork}}\n\n\n\n\nReturns \nnodf\n for a margin of the network. The \ni\n argument can be 1 for top-level, 2 for bottom level, and the function will throw an \nArgumentError\n if an invalid value is used. For quantitative networks, \nWNODF\n is used.\n\n\nsource", 
            "title": "Nestedness"
        }, 
        {
            "location": "/properties/nestedness/#nestedness", 
            "text": "#  EcologicalNetwork.\u03b7     Function .  \u03b7(N::T) where {T  : Union{BipartiteNetwork, BipartiteProbaNetwork}}  This returns the nestedness of the entire matrix.  source  \u03b7(N::T, i::Int64) where {T  : Union{BipartiteNetwork, BipartiteProbaNetwork}}  Returns the nestedness of a margin of the network, using \u03b7. The second argument can be  1  (for nestedness of rows/top level) or  2  (for nestedness of columns/bottom level). This function will throw an  ArgumentError  if you use an invalid value for  i .  source  #  EcologicalNetwork.nodf     Function .  nodf(N::T) where {T  : Union{BipartiteNetwork,BipartiteQuantitativeNetwork}}  If the network is quantitative, then  WNODF  is measured instead of  NODF . Note that in  all  situations, the value goes between 0 (not nested) to 1 (perfectly nested). This is a change with regard to the original papers, in which the maximal value is 100. The nestedness for the entire network is returned.  source  nodf(N::T, i::Int64) where {T  : Union{BipartiteNetwork,BipartiteQuantitativeNetwork}}  Returns  nodf  for a margin of the network. The  i  argument can be 1 for top-level, 2 for bottom level, and the function will throw an  ArgumentError  if an invalid value is used. For quantitative networks,  WNODF  is used.  source", 
            "title": "Nestedness"
        }, 
        {
            "location": "/properties/motifs/", 
            "text": "Motif enumeration\n\n\n\n\nExample\n\n\nN = last(nz_stream_foodweb())\nlength(find_motif(N, unipartitemotifs()[:S1]))\n\n\n\n\n186\n\n\n\n\n\n\nList of canonical motifs\n\n\n#\n\n\nEcologicalNetwork.unipartitemotifs\n \n \nFunction\n.\n\n\nunipartitemotifs()\n\n\n\n\nThe names of the motifs come from Stouffer et al. (2007) \u2013 especially Fig. 1, available online at \nhttp://rspb.royalsocietypublishing.org/content/274/1621/1931.figures-only\n\n\nThe motifs are returned as a dictionary, with each motif identified by its name.\n\n\nsource\n\n\n\n\nMotif counting\n\n\n#\n\n\nEcologicalNetwork.find_motif\n \n \nFunction\n.\n\n\nfind_motif(N::T1, m::T2) where {T1\n:AbstractEcologicalNetwork, T2\n:BinaryNetwork}\n\n\n\n\nReturns an array of tuples, in which each tuple contains the species that are part of the motif. The length of the array gives the number of times the motif was found. For probabilistic networks, the tuple also contains the probability of observing the species in the correct conformation for the motif, as well as the variance.\n\n\nsource\n\n\n\n\nProbabilistic case\n\n\n#\n\n\nEcologicalNetwork.expected_motif_count\n \n \nFunction\n.\n\n\nexpected_motif_count(s)\n\n\n\n\nGet the expected number of motifs (and variance) from the output of \nfind_motif\n on a probabilistic network.\n\n\nsource", 
            "title": "Motifs"
        }, 
        {
            "location": "/properties/motifs/#motif-enumeration", 
            "text": "", 
            "title": "Motif enumeration"
        }, 
        {
            "location": "/properties/motifs/#example", 
            "text": "N = last(nz_stream_foodweb())\nlength(find_motif(N, unipartitemotifs()[:S1]))  186", 
            "title": "Example"
        }, 
        {
            "location": "/properties/motifs/#list-of-canonical-motifs", 
            "text": "#  EcologicalNetwork.unipartitemotifs     Function .  unipartitemotifs()  The names of the motifs come from Stouffer et al. (2007) \u2013 especially Fig. 1, available online at  http://rspb.royalsocietypublishing.org/content/274/1621/1931.figures-only  The motifs are returned as a dictionary, with each motif identified by its name.  source", 
            "title": "List of canonical motifs"
        }, 
        {
            "location": "/properties/motifs/#motif-counting", 
            "text": "#  EcologicalNetwork.find_motif     Function .  find_motif(N::T1, m::T2) where {T1 :AbstractEcologicalNetwork, T2 :BinaryNetwork}  Returns an array of tuples, in which each tuple contains the species that are part of the motif. The length of the array gives the number of times the motif was found. For probabilistic networks, the tuple also contains the probability of observing the species in the correct conformation for the motif, as well as the variance.  source", 
            "title": "Motif counting"
        }, 
        {
            "location": "/properties/motifs/#probabilistic-case", 
            "text": "#  EcologicalNetwork.expected_motif_count     Function .  expected_motif_count(s)  Get the expected number of motifs (and variance) from the output of  find_motif  on a probabilistic network.  source", 
            "title": "Probabilistic case"
        }, 
        {
            "location": "/properties/paths/", 
            "text": "Paths and centrality\n\n\n\n\nNumber of paths and shortest path\n\n\n#\n\n\nEcologicalNetwork.number_of_paths\n \n \nFunction\n.\n\n\nnumber_of_paths(N::Unipartite; n::Int64=2)\n\n\n\n\nThis returns an array, not a network.\n\n\n\n\nn\n (def. 2), the path length\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.shortest_path\n \n \nFunction\n.\n\n\nshortest_path(N::UnipartiteNetwork; nmax::Int64=50)\n\n\n\n\nThis is not an optimal algorithm \nat all\n, but it will do given that most ecological networks are relatively small. The optional \nnmax\n argument is the longest shortest path length you will look for.\n\n\nIn ecological networks, the longest shortest path tends not to be very long, so any value above 10 is probably overdoing it. Note that the default value is 50, which is above 10.\n\n\nsource\n\n\nshortest_path(N::UnipartiteQuantiNetwork; nmax::Int64=50)\n\n\n\n\nThis function will remove quantitative information, then measure the shortest path length.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.bellman_ford\n \n \nFunction\n.\n\n\nbellman_ford(N::T, source::K) where {T \n: DeterministicNetwork, K \n: AllowedSpeciesTypes}\n\n\n\n\nBellman-ford algorithm to return the shortest / easiest paths from a source species. Refer to the \nbellman_ford\n global documentation for the output format.\n\n\nsource\n\n\nbellman_ford(N::T) where {T \n: DeterministicNetwork}\n\n\n\n\nBellman-ford algorithm to return the shortest / easiest paths between all pairs of species in the networks, as long as paths exists. This function will return a tuple, with fields \nfrom\n, \nto\n and \nweight\n. The number of elements in the tuple is the number of paths. This function works with quantitative and binary networks, and assumes that no interactions are negative.\n\n\nCurrently, the Bellman-Ford algorithm is \nslower\n than the \nshortest_path\n function, but the arguments are returned in a more usable way. Note that the speed penalty is only valid when measuring the shortest paths in the entire network (and will be fixed relatively soon), and does not apply as much for the shortest paths from a single source node. \n\n\nsource\n\n\n\n\nCentrality measures\n\n\n#\n\n\nEcologicalNetwork.centrality_degree\n \n \nFunction\n.\n\n\nDegree centrality\n\n\ncentrality_degree(N::UnipartiteNetwork)\n\n\n\n\nDegree centrality, corrected by the maximum degree (the most central species has a degree of 1).\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.centrality_closeness\n \n \nFunction\n.\n\n\ncentrality_closeness(N::UnipartiteNetwork; nmax::Int64=100)\n\n\n\n\nThe function calls \nshortest_path\n internally \u2013 the \nnmax\n argument is the maximal path length that wil be tried.\n\n\n\n\nBavelas, A., 1950. Communication Patterns in Task\u2010Oriented Groups. The Journal of the Acoustical Society of America 22, 725\u2013730. doi:10.1121/1.1906679\n\n\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.centrality_katz\n \n \nFunction\n.\n\n\nKatz's centrality\n\n\ncentrality_katz(N::Unipartite; a::Float64=0.1, k::Int64=5)\n\n\n\n\nThis measure can work on different path length (\nk\n), and give a different weight to every subsequent connection (\na\n). \nk\n must be at least 1 (only immediate neighbors are considered). \na\n (being a weight), must be positive.\n\n\n\n\nKatz, L., 1953. A new status index derived from sociometric analysis. Psychometrika 18, 39\u201343. doi:10.1007/bf02289026\n\n\n\n\nsource", 
            "title": "Centrality and paths"
        }, 
        {
            "location": "/properties/paths/#paths-and-centrality", 
            "text": "", 
            "title": "Paths and centrality"
        }, 
        {
            "location": "/properties/paths/#number-of-paths-and-shortest-path", 
            "text": "#  EcologicalNetwork.number_of_paths     Function .  number_of_paths(N::Unipartite; n::Int64=2)  This returns an array, not a network.   n  (def. 2), the path length   source  #  EcologicalNetwork.shortest_path     Function .  shortest_path(N::UnipartiteNetwork; nmax::Int64=50)  This is not an optimal algorithm  at all , but it will do given that most ecological networks are relatively small. The optional  nmax  argument is the longest shortest path length you will look for.  In ecological networks, the longest shortest path tends not to be very long, so any value above 10 is probably overdoing it. Note that the default value is 50, which is above 10.  source  shortest_path(N::UnipartiteQuantiNetwork; nmax::Int64=50)  This function will remove quantitative information, then measure the shortest path length.  source  #  EcologicalNetwork.bellman_ford     Function .  bellman_ford(N::T, source::K) where {T  : DeterministicNetwork, K  : AllowedSpeciesTypes}  Bellman-ford algorithm to return the shortest / easiest paths from a source species. Refer to the  bellman_ford  global documentation for the output format.  source  bellman_ford(N::T) where {T  : DeterministicNetwork}  Bellman-ford algorithm to return the shortest / easiest paths between all pairs of species in the networks, as long as paths exists. This function will return a tuple, with fields  from ,  to  and  weight . The number of elements in the tuple is the number of paths. This function works with quantitative and binary networks, and assumes that no interactions are negative.  Currently, the Bellman-Ford algorithm is  slower  than the  shortest_path  function, but the arguments are returned in a more usable way. Note that the speed penalty is only valid when measuring the shortest paths in the entire network (and will be fixed relatively soon), and does not apply as much for the shortest paths from a single source node.   source", 
            "title": "Number of paths and shortest path"
        }, 
        {
            "location": "/properties/paths/#centrality-measures", 
            "text": "#  EcologicalNetwork.centrality_degree     Function .  Degree centrality  centrality_degree(N::UnipartiteNetwork)  Degree centrality, corrected by the maximum degree (the most central species has a degree of 1).  source  #  EcologicalNetwork.centrality_closeness     Function .  centrality_closeness(N::UnipartiteNetwork; nmax::Int64=100)  The function calls  shortest_path  internally \u2013 the  nmax  argument is the maximal path length that wil be tried.   Bavelas, A., 1950. Communication Patterns in Task\u2010Oriented Groups. The Journal of the Acoustical Society of America 22, 725\u2013730. doi:10.1121/1.1906679   source  #  EcologicalNetwork.centrality_katz     Function .  Katz's centrality  centrality_katz(N::Unipartite; a::Float64=0.1, k::Int64=5)  This measure can work on different path length ( k ), and give a different weight to every subsequent connection ( a ).  k  must be at least 1 (only immediate neighbors are considered).  a  (being a weight), must be positive.   Katz, L., 1953. A new status index derived from sociometric analysis. Psychometrika 18, 39\u201343. doi:10.1007/bf02289026   source", 
            "title": "Centrality measures"
        }, 
        {
            "location": "/properties/randomization/", 
            "text": "Randomization of networks\n\n\nRandomization of networks is mostly used to perform null hypothesis significance testing, or to draw random realizations of a probabilistic network. There are two ways to perform networks randomization: either by shuffling interactions within the networks while enforcing some constraints (\nshuffle\n) or by drawing random samples from a probabilistic network (\nrand\n).\n\n\n\n\nDraw a network from a probabilistic network\n\n\n#\n\n\nBase.Random.rand\n \n \nFunction\n.\n\n\nrand(N::ProbabilisticNetwork)\n\n\n\n\nConverts a probabilistic network into a deterministic one by performing random draws. All interactions are treated as independent Bernoulli events. Note that this network is \nnot\n check for degeneracy, \ni.e.\n species can end up with no interactions.\n\n\nsource\n\n\nrand(N::ProbabilisticNetwork, n::T) where {T\n:Integer}\n\n\n\n\nGenerates a number of random deterministic networks based on a probabilistic network.\n\n\nsource\n\n\n\n\nGenerate probabilistic networks from deterministic networks\n\n\nThese functions generate a probabilistic network from a deterministic network, where the probability of every interaction is determined by the degree distribution (or connectance) of the network.\n\n\n#\n\n\nEcologicalNetwork.null1\n \n \nFunction\n.\n\n\nnull1(N::BinaryNetwork)\n\n\n\n\nGiven a matrix \nA\n, \nnull1(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the connectance of \nA\n.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null2\n \n \nFunction\n.\n\n\nnull2(N::BinaryNetwork)\n\n\n\n\nGiven a matrix \nA\n, \nnull2(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the degree of each species.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null3in\n \n \nFunction\n.\n\n\nnull3in(N::BinaryNetwork)\n\n\n\n\nGiven a matrix \nA\n, \nnull3in(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the in-degree (number of predecessors) of each species, divided by the total number of possible predecessors.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.null3out\n \n \nFunction\n.\n\n\nnull3out(N::BinaryNetwork)\n\n\n\n\nGiven a matrix \nA\n, \nnull3out(A)\n returns a matrix with the same dimensions, where every interaction happens with a probability equal to the out-degree (number of successors) of each species, divided by the total number of possible successors.\n\n\nsource\n\n\n\n\nShuffle interactions\n\n\n#\n\n\nBase.Random.shuffle!\n \n \nFunction\n.\n\n\nshuffle!(N::BinaryNetwork; constraint::Symbol=:degree, number_of_swaps::Int64=1000)\n\n\n\n\nShuffles interactions inside a network (the network is \nmodified\n), under the following \nconstraint\n:\n\n\n\n\n:degree, which keeps the degree distribution intact\n\n\n:generality, which keeps the out-degree distribution intact\n\n\n:vulnerability, which keeps the in-degree distribution intact\n\n\n:fill, which moves interactions around freely\n\n\n\n\nNote that this function will conserve the degree (when appropriate under the selected constraint) of \nevery\n species. This function will take number_of_swaps (1000) interactions, swap them, and return a copy of the network.\n\n\nIf the keyword arguments are invalid, the function will throw an \nArgumentError\n.\n\n\nsource\n\n\n#\n\n\nBase.Random.shuffle\n \n \nFunction\n.\n\n\nshuffle(N::BinaryNetwork; constraint::Symbol=:degree, number_of_swaps::Int64=1000)\n\n\n\n\nReturn a shuffled copy of the network. See \nshuffle!\n for a documentation of the keyword arguments.\n\n\nsource", 
            "title": "Randomization"
        }, 
        {
            "location": "/properties/randomization/#randomization-of-networks", 
            "text": "Randomization of networks is mostly used to perform null hypothesis significance testing, or to draw random realizations of a probabilistic network. There are two ways to perform networks randomization: either by shuffling interactions within the networks while enforcing some constraints ( shuffle ) or by drawing random samples from a probabilistic network ( rand ).", 
            "title": "Randomization of networks"
        }, 
        {
            "location": "/properties/randomization/#draw-a-network-from-a-probabilistic-network", 
            "text": "#  Base.Random.rand     Function .  rand(N::ProbabilisticNetwork)  Converts a probabilistic network into a deterministic one by performing random draws. All interactions are treated as independent Bernoulli events. Note that this network is  not  check for degeneracy,  i.e.  species can end up with no interactions.  source  rand(N::ProbabilisticNetwork, n::T) where {T :Integer}  Generates a number of random deterministic networks based on a probabilistic network.  source", 
            "title": "Draw a network from a probabilistic network"
        }, 
        {
            "location": "/properties/randomization/#generate-probabilistic-networks-from-deterministic-networks", 
            "text": "These functions generate a probabilistic network from a deterministic network, where the probability of every interaction is determined by the degree distribution (or connectance) of the network.  #  EcologicalNetwork.null1     Function .  null1(N::BinaryNetwork)  Given a matrix  A ,  null1(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the connectance of  A .  source  #  EcologicalNetwork.null2     Function .  null2(N::BinaryNetwork)  Given a matrix  A ,  null2(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the degree of each species.  source  #  EcologicalNetwork.null3in     Function .  null3in(N::BinaryNetwork)  Given a matrix  A ,  null3in(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the in-degree (number of predecessors) of each species, divided by the total number of possible predecessors.  source  #  EcologicalNetwork.null3out     Function .  null3out(N::BinaryNetwork)  Given a matrix  A ,  null3out(A)  returns a matrix with the same dimensions, where every interaction happens with a probability equal to the out-degree (number of successors) of each species, divided by the total number of possible successors.  source", 
            "title": "Generate probabilistic networks from deterministic networks"
        }, 
        {
            "location": "/properties/randomization/#shuffle-interactions", 
            "text": "#  Base.Random.shuffle!     Function .  shuffle!(N::BinaryNetwork; constraint::Symbol=:degree, number_of_swaps::Int64=1000)  Shuffles interactions inside a network (the network is  modified ), under the following  constraint :   :degree, which keeps the degree distribution intact  :generality, which keeps the out-degree distribution intact  :vulnerability, which keeps the in-degree distribution intact  :fill, which moves interactions around freely   Note that this function will conserve the degree (when appropriate under the selected constraint) of  every  species. This function will take number_of_swaps (1000) interactions, swap them, and return a copy of the network.  If the keyword arguments are invalid, the function will throw an  ArgumentError .  source  #  Base.Random.shuffle     Function .  shuffle(N::BinaryNetwork; constraint::Symbol=:degree, number_of_swaps::Int64=1000)  Return a shuffled copy of the network. See  shuffle!  for a documentation of the keyword arguments.  source", 
            "title": "Shuffle interactions"
        }, 
        {
            "location": "/properties/betadiversity/", 
            "text": "Network \u03b2-diversity\n\n\nMeasures of \u03b2-diversity work by first calculating the unique/shared items (using the \n\u03b2s\n, \n\u03b2os\n, and \n\u03b2wn\n functions), then passing on these arguments to one of the \nKGLXX\n functions to return a (dis)similarity score. The \nKGL\n functions are named for Koleff, Gaston, and Lennon \u2013 the number of each function matches the number in Table 1.\n\n\n\n\n\u03b2-diversity components\n\n\nThe package implements functions for the \u03b2s, \u03b2os, and \u03b2wn components of network dissimilarity. In the original publication, we also described \u03b2st, which was the proprotion of dissimilarity due to species turnover, and defined as \u03b2st = \u03b2wn - \u03b2os \nfor measures of dissimilarity bounded between 0 and 1\n. After discussing with colleagues and considering our own use-cases, it appears that the interpretation of \u03b2st is not always straightforward, and so we have decided to exclude it form the available functions.\n\n\n#\n\n\nEcologicalNetwork.\u03b2s\n \n \nFunction\n.\n\n\n\u03b2s(X::T, Y::T) where {T\n:BinaryNetwork}\n\n\n\n\nComponents of \u03b2-diversity as measured on species.\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.\u03b2os\n \n \nFunction\n.\n\n\nOverlapping species (bipartite)\n\n\nsource\n\n\nOverlapping species (unipartite)\n\n\nsource\n\n\n#\n\n\nEcologicalNetwork.\u03b2wn\n \n \nFunction\n.\n\n\nWhole network\n\n\nsource\n\n\nOne measure which is possibly missing is a function to build the metaweb, \ni.e.\n aggregate all species and interactions in a collection of networks. This can be done using \nunion\n, \ne.g.\n\n\nN = nz_stream_foodweb() # Or any collection of networks\nmetaweb = reduce(union, N)\n\n\n\n\n\n\n\u03b2-diversity measures\n\n\n#\n\n\nEcologicalNetwork.KGL01\n \n \nFunction\n.\n\n\nKGL01(S::T)\n\n\n\n\nWhittaker\n\n\nsource\n\n\n\n\nBasic operations on networks\n\n\nInternally, the functions for \u03b2-diversity rely on the usual operations on sets. The act of combining two networks, for example, is a \nunion\n operation.\n\n\n#\n\n\nBase.setdiff\n \n \nFunction\n.\n\n\nsetdiff(X::T, Y::T) where {T\n:BipartiteNetwork}\n\n\n\n\nDifference between two bipartite networks. This operation is \nsensitive\n to the order of arguments, as the resulting network will have the species present in the first network (and their interactions) only.\n\n\nsource\n\n\nsetdiff(X::T, Y::T) where {T\n:UnipartiteNetwork}\n\n\n\n\nDifference between two unipartite networks. This operation is \nsensitive\n to the order of arguments, as the resulting network will have the species present in the first network (and their interactions) only.\n\n\nsource\n\n\n#\n\n\nBase.union\n \n \nFunction\n.\n\n\nunion(X::T, Y::T) where {T\n:BipartiteNetwork}\n\n\n\n\nUnion of two bipartite networks \u2013 interactions \nand\n species which are present in either networks are also present in the final network.\n\n\nsource\n\n\nunion(X::T, Y::T) where {T\n:UnipartiteNetwork}\n\n\n\n\nUnion of two unipartite networks \u2013 interactions \nand\n species which are present in either networks are also present in the final network.\n\n\nsource\n\n\n#\n\n\nBase.intersect\n \n \nFunction\n.\n\n\nintersect(X::T, Y::T) where {T\n:BipartiteNetwork}\n\n\n\n\nIntersect between two bipartite networks. The resulting network has the \nspecies and interactions\n common to both networks. This can result in species being disconnected, if they are found in both networks but with no operations in common.\n\n\nsource\n\n\nintersect(X::T, Y::T) where {T\n:UnipartiteNetwork}\n\n\n\n\nIntersect between two unipartite networks. The resulting network has the \nspecies and interactions\n common to both networks. This can result in species being disconnected, if they are found in both networks but with no operations in common.\n\n\nsource", 
            "title": "\u03b2-diversity"
        }, 
        {
            "location": "/properties/betadiversity/#network-diversity", 
            "text": "Measures of \u03b2-diversity work by first calculating the unique/shared items (using the  \u03b2s ,  \u03b2os , and  \u03b2wn  functions), then passing on these arguments to one of the  KGLXX  functions to return a (dis)similarity score. The  KGL  functions are named for Koleff, Gaston, and Lennon \u2013 the number of each function matches the number in Table 1.", 
            "title": "Network \u03b2-diversity"
        }, 
        {
            "location": "/properties/betadiversity/#-diversity-components", 
            "text": "The package implements functions for the \u03b2s, \u03b2os, and \u03b2wn components of network dissimilarity. In the original publication, we also described \u03b2st, which was the proprotion of dissimilarity due to species turnover, and defined as \u03b2st = \u03b2wn - \u03b2os  for measures of dissimilarity bounded between 0 and 1 . After discussing with colleagues and considering our own use-cases, it appears that the interpretation of \u03b2st is not always straightforward, and so we have decided to exclude it form the available functions.  #  EcologicalNetwork.\u03b2s     Function .  \u03b2s(X::T, Y::T) where {T :BinaryNetwork}  Components of \u03b2-diversity as measured on species.  source  #  EcologicalNetwork.\u03b2os     Function .  Overlapping species (bipartite)  source  Overlapping species (unipartite)  source  #  EcologicalNetwork.\u03b2wn     Function .  Whole network  source  One measure which is possibly missing is a function to build the metaweb,  i.e.  aggregate all species and interactions in a collection of networks. This can be done using  union ,  e.g.  N = nz_stream_foodweb() # Or any collection of networks\nmetaweb = reduce(union, N)", 
            "title": "\u03b2-diversity components"
        }, 
        {
            "location": "/properties/betadiversity/#-diversity-measures", 
            "text": "#  EcologicalNetwork.KGL01     Function .  KGL01(S::T)  Whittaker  source", 
            "title": "\u03b2-diversity measures"
        }, 
        {
            "location": "/properties/betadiversity/#basic-operations-on-networks", 
            "text": "Internally, the functions for \u03b2-diversity rely on the usual operations on sets. The act of combining two networks, for example, is a  union  operation.  #  Base.setdiff     Function .  setdiff(X::T, Y::T) where {T :BipartiteNetwork}  Difference between two bipartite networks. This operation is  sensitive  to the order of arguments, as the resulting network will have the species present in the first network (and their interactions) only.  source  setdiff(X::T, Y::T) where {T :UnipartiteNetwork}  Difference between two unipartite networks. This operation is  sensitive  to the order of arguments, as the resulting network will have the species present in the first network (and their interactions) only.  source  #  Base.union     Function .  union(X::T, Y::T) where {T :BipartiteNetwork}  Union of two bipartite networks \u2013 interactions  and  species which are present in either networks are also present in the final network.  source  union(X::T, Y::T) where {T :UnipartiteNetwork}  Union of two unipartite networks \u2013 interactions  and  species which are present in either networks are also present in the final network.  source  #  Base.intersect     Function .  intersect(X::T, Y::T) where {T :BipartiteNetwork}  Intersect between two bipartite networks. The resulting network has the  species and interactions  common to both networks. This can result in species being disconnected, if they are found in both networks but with no operations in common.  source  intersect(X::T, Y::T) where {T :UnipartiteNetwork}  Intersect between two unipartite networks. The resulting network has the  species and interactions  common to both networks. This can result in species being disconnected, if they are found in both networks but with no operations in common.  source", 
            "title": "Basic operations on networks"
        }
    ]
}